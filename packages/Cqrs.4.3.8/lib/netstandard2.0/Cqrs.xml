<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Cqrs</name>
    </assembly>
    <members>
        <member name="T:Cqrs.Authentication.AuthenticationTokenHelper">
            <summary>
            A helper for setting and retrieving authentication tokens of type 
            <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn"/>
            or <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.#ctor(Chinchilla.StateManagement.IContextItemCollectionFactory)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Authentication.AuthenticationTokenHelper"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.ISingleSignOnTokenWithUserRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#ISingleSignOnTokenWithUserRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#ISingleSignOnTokenWithCompanyRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#ISingleSignOnTokenWithUserRsnAndCompanyRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.AuthenticationTokenHelper`1">
            <summary>
            A helper for setting and retrieving authentication tokens of type <typeparamref name="TAuthenticationToken"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="F:Cqrs.Authentication.AuthenticationTokenHelper`1.CacheKey">
            <summary>
            The key used to store the authentication token in the <see cref="P:Cqrs.Authentication.AuthenticationTokenHelper`1.Cache"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.AuthenticationTokenHelper`1.Cache">
            <summary>
            Get or set the Cache.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper`1.#ctor(Chinchilla.StateManagement.IContextItemCollectionFactory)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Authentication.AuthenticationTokenHelper`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper`1.SetAuthenticationToken(`0)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper`1.GetAuthenticationToken">
            <summary>
            Get the current <typeparamref name="TAuthenticationToken">authentication token</typeparamref> for the current context/request.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.BasicTokenResolver">
            <summary>
            Resolves basic, known parameter types when serialising with WCF.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.BasicTokenResolver.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Indicates if the provided <paramref name="dataContractType"/> is of type <see cref="T:System.Guid"/>, <see cref="T:System.Nullable`1"/>, <see cref="T:System.Int32"/>, <see cref="T:System.Nullable`1"/>, <see cref="T:System.String"/>
            OR if it is other resolvable.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.BasicTokenResolver.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Returns the <see cref="T:System.Type"/> if the <paramref name="typeName"/> is resolvable or if it is 
            of type <see cref="T:System.Guid"/>, <see cref="T:System.Nullable`1"/>, <see cref="T:System.Int32"/>, <see cref="T:System.Nullable`1"/> and <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.DefaultAuthenticationTokenHelper">
            <summary>
            A helper for setting and retrieving authentication tokens of type 
            <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn"/>
            <see cref="T:System.Int32"/>, <see cref="T:System.Guid"/> or <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.#ctor(Chinchilla.StateManagement.IContextItemCollectionFactory)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Authentication.DefaultAuthenticationTokenHelper"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.SingleSignOnTokenWithUserRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#SingleSignOnTokenWithUserRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(System.Guid)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(System.Int32)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(System.String)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#SingleSignOnTokenWithCompanyRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#SingleSignOnTokenWithUserRsnAndCompanyRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{System#Int32}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:System.Int32">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{System#Guid}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:System.Guid">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{System#String}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:System.String">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.DefaultSingleSignOnTokenFactory">
            <summary>
            A Factory for creating new authentication tokens of type <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultSingleSignOnTokenFactory.Cqrs#Authentication#IDefaultSingleSignOnTokenFactory#RenewTokenExpiry(Cqrs.Authentication.ISingleSignOnToken,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/>.</param>
        </member>
        <member name="M:Cqrs.Authentication.DefaultSingleSignOnTokenFactory.RenewTokenExpiry``1(``0,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/>.</param>
        </member>
        <member name="T:Cqrs.Authentication.IAuthenticationTokenHelper`1">
            <summary>
            A helper for setting and retrieving authentication tokens of type <typeparamref name="TAuthenticationToken"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Authentication.IAuthenticationTokenHelper`1.GetAuthenticationToken">
            <summary>
            Get the current <typeparamref name="TAuthenticationToken">authentication token</typeparamref> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.IAuthenticationTokenHelper`1.SetAuthenticationToken(`0)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.IDefaultSingleSignOnTokenFactory">
            <summary>
            A Factory for creating new authentication tokens of type <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.IDefaultSingleSignOnTokenFactory.RenewTokenExpiry(Cqrs.Authentication.ISingleSignOnToken,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnToken">
            <summary>
            An authentication token with expiry and an issue time information.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnToken.Token">
            <summary>
            The authentication token.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry">
            <summary>
            The <see cref="T:System.DateTime"/> this token should expire.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnToken.DateIssued">
            <summary>
            The <see cref="T:System.DateTime"/> this token was issued.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.ISingleSignOnToken.Serialise">
            <summary>
            Serialises this token to a string.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnTokenFactory`1">
            <summary>
            A factory for creating new authentication tokens of type <typeparamref name="TSingleSignOnToken"/>.
            </summary>
            <typeparam name="TSingleSignOnToken">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/>.</typeparam>
        </member>
        <member name="M:Cqrs.Authentication.ISingleSignOnTokenFactory`1.CreateNew(System.Int32)">
            <summary>
            Create a new <typeparamref name="TSingleSignOnToken"/>.
            </summary>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="M:Cqrs.Authentication.ISingleSignOnTokenFactory`1.RenewTokenExpiry(`0,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> that includes an identifiable <see cref="P:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn.CompanyRsn"/> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn.CompanyRsn">
            <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> that includes an identifiable <see cref="P:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn.UserRsn"/> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn.UserRsn">
            <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn"/> and <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn"/>
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnToken">
            <summary>
            An authentication token with expiry and an issue time information.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnToken.Token">
            <summary>
            The authentication token.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnToken.TimeOfExpiry">
            <summary>
            The <see cref="T:System.DateTime"/> this token should expire.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnToken.DateIssued">
            <summary>
            The <see cref="T:System.DateTime"/> this token was issued.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnToken.Serialise">
            <summary>
            Returns <see cref="P:Cqrs.Authentication.SingleSignOnToken.Token"/>.
            </summary>
            <returns><see cref="P:Cqrs.Authentication.SingleSignOnToken.Token"/>.</returns>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenFactory`1">
            <summary>
            A factory for creating new authentication tokens of type <typeparamref name="TSingleSignOnToken"/>.
            </summary>
            <typeparam name="TSingleSignOnToken">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/>.</typeparam>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenFactory`1.CreateNew(System.Int32)">
            <summary>
            Create a new <typeparamref name="TSingleSignOnToken"/>.
            </summary>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenFactory`1.RenewTokenExpiry(`0,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenResolver">
            <summary>
            Resolves parameter types when serialising with WCF of <see cref="T:System.Type"/>
            <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn"/> and <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenResolver.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Indicates if the provided <paramref name="dataContractType"/> is of type <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn"/>
            OR if it is other resolvable.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenResolver.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Returns the <see cref="T:System.Type"/> if the <paramref name="typeName"/> is resolvable or if it is 
            of type <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn"/> and <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn"/>
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> that includes an identifiable <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn"/> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn">
            <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.Serialise">
            <summary>
            Returns <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn"/>.
            </summary>
            <returns><see cref="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn"/>.</returns>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> that includes an identifiable <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn"/> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn">
            <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.Serialise">
            <summary>
            Returns <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn"/>.
            </summary>
            <returns><see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn"/>.</returns>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn"/> and <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn"/>
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.CompanyRsn">
            <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.UserRsn">
            <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.Serialise">
            <summary>
            Returns <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.CompanyRsn"/> and <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.UserRsn"/>.
            </summary>
            <returns><see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.CompanyRsn"/> and <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.UserRsn"/>.</returns>
        </member>
        <member name="T:Cqrs.Bus.BuiltInHashAlgorithmFactory">
            <summary>
            A factory for creating new instances of <see cref="T:System.Security.Cryptography.HashAlgorithm"/>, used for signing network messages.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BuiltInHashAlgorithmFactory.Create">
            <summary>
            Creates a new instance of <see cref="T:System.Security.Cryptography.HashAlgorithm"/> using <see cref="M:System.Security.Cryptography.SHA512.Create"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.BusHelper">
            <summary>
            A helper for command and event buses that also caches <see cref="T:Cqrs.Configuration.IConfigurationManager"/> look ups.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.#ctor(Cqrs.Configuration.IConfigurationManager,Chinchilla.StateManagement.IContextItemCollectionFactory)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Bus.BusHelper"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.BusHelper.ConfigurationManager">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IConfigurationManager"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.BusHelper.CachedChecks">
            <summary>
            A collection of <see cref="T:System.Tuple`2"/> holding the configurations value (always a <see cref="T:System.Boolean"/>) and the <see cref="T:System.DateTime"/>
            The value was last checked, keyed by it's configuration key.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.BusHelper.NullableCachedChecks">
            <summary>
            A collection of <see cref="T:System.Tuple`2"/> holding the configurations value (always a <see cref="T:System.Boolean"/>) and the <see cref="T:System.DateTime"/>
            The value was last checked, keyed by it's configuration key.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.BusHelper.EventBlackListProcessing">
            <summary>
            The current value of "Cqrs.MessageBus.BlackListProcessing" from <see cref="P:Cqrs.Bus.BusHelper.ConfigurationManager"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.RefreshCachedChecks">
            <summary>
            Refreshes <see cref="P:Cqrs.Bus.BusHelper.EventBlackListProcessing"/> and every item currently in <see cref="P:Cqrs.Bus.BusHelper.CachedChecks"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.StartRefreshCachedChecks">
            <summary>
            Starts <see cref="M:Cqrs.Bus.BusHelper.RefreshCachedChecks"/> in a <see cref="T:System.Threading.Tasks.Task"/> on a one second loop.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.IsEventRequired(System.Type)">
            <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager"/> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.IsEventRequired(System.String)">
            <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager"/> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
            <param name="configurationKey">The configuration key to check.</param>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.IsPrivateBusRequired(System.Type)">
            <summary>
            Checks if the private bus is required to send the message. Note, this does not imply the public bus is not required as well.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
            <returns>Null for unconfigured, True for private bus transmission, false otherwise.</returns>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.IsPublicBusRequired(System.Type)">
            <summary>
            Checks if the public bus is required to send the message. Note, this does not imply the public bus is not required as well.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
            <returns>Null for unconfigured, True for private bus transmission, false otherwise.</returns>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.IsABusRequired(System.Type,System.Boolean)">
            <summary>
            Checks if the particular bus is required to send the message. Note, this does not imply the public bus is not required as well.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
            <param name="checkPublic">Check for the public or private bus.</param>
            <returns>Null for unconfigured, True for a particular bus transmission, false otherwise.</returns>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.BuildTelemeteredActionHandler``2(Chinchilla.Logging.ITelemetryHelper,System.Action{``0},System.Boolean,System.String)">
            <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.BuildActionHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
        </member>
        <member name="F:Cqrs.Bus.BusHelper.CacheKey">
            <summary>
            The key used to store the authentication token in the <see cref="P:Cqrs.Bus.BusHelper.Cache"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.BusHelper.Cache">
            <summary>
            Get or set the Cache.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.GetWasPrivateBusUsed">
            <summary>
            Indicates if the message was received via the private bus or not. If false, this implies the public was use used.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.SetWasPrivateBusUsed(System.Boolean)">
            <summary>
            Set whether the message was received via the private bus or not. If false, this indicates the public was use used.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.FileBasedLastEventProcessedStore">
            <summary>
            Indicates the position in a store where the stream has been read up to by storing the value in a file.
            </summary>
        </member>
        <member name="F:Cqrs.Bus.FileBasedLastEventProcessedStore.AppSettingsKey">
            <summary>
            The configuration setting that holds the location of file to store position information in.
            </summary>
        </member>
        <member name="F:Cqrs.Bus.FileBasedLastEventProcessedStore.AppSettingsDefaultValue">
            <summary>
            The default location of the file to store position information in.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.FileBasedLastEventProcessedStore.FileName">
            <summary>
            The relative or absolute path of the file to store the current location in
            </summary>
        </member>
        <member name="M:Cqrs.Bus.FileBasedLastEventProcessedStore.#ctor(Cqrs.Configuration.IConfigurationManager)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Bus.FileBasedLastEventProcessedStore"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.FileBasedLastEventProcessedStore.EventLocation">
            <summary>
            Reads and writes the location within the store where the stream has been read up to <see cref="P:Cqrs.Bus.FileBasedLastEventProcessedStore.FileName"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IBusHelper">
            <summary>
            A helper for command and event buses.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.IsEventRequired(System.Type)">
            <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager"/> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.IsEventRequired(System.String)">
            <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager"/> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
            <param name="configurationKey">The configuration key to check.</param>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.IsPrivateBusRequired(System.Type)">
            <summary>
            Checks if the private bus is required to send the message. Note, this does not imply the public bus is not required as well.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
            <returns>Null for unconfigured, True for private bus transmission, false otherwise.</returns>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.IsPublicBusRequired(System.Type)">
            <summary>
            Checks if the public bus is required to send the message. Note, this does not imply the public bus is not required as well.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
            <returns>Null for unconfigured, True for private bus transmission, false otherwise.</returns>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.BuildTelemeteredActionHandler``2(Chinchilla.Logging.ITelemetryHelper,System.Action{``0},System.Boolean,System.String)">
            <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.BuildActionHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.GetWasPrivateBusUsed">
            <summary>
            Indicates if the message was received via the private bus or not. If false, this implies the public was use used.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.SetWasPrivateBusUsed(System.Boolean)">
            <summary>
            Set whether the message was received via the private bus or not. If false, this indicates the public was use used.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.ICommandHandlerRegistrar">
            <summary>
            Registers command handlers that listen and respond to commands.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IEventHandlerRegistrar">
            <summary>
            Registers event handlers that listen and respond to events.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IEventHandlerRegistrar.RegisterGlobalEventHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event handler that will listen and respond to all events.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IHandlerRegistrar">
            <summary>
            Registers event or command handlers that listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
            <remarks>
            In many cases the <paramref name="targetedType"/> will be the handler class itself, what you actually want is the target of what is being updated.
            </remarks>
        </member>
        <member name="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IHashAlgorithmFactory">
            <summary>
            A factory for creating new instances of <see cref="T:System.Security.Cryptography.HashAlgorithm"/>, used for signing network messages.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IHashAlgorithmFactory.Create">
            <summary>
            Creates a new instance of <see cref="T:System.Security.Cryptography.HashAlgorithm"/>, used for signing network messages.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.InProcessBus`1">
            <summary>
            An in process command bus 
            (<see cref="T:Cqrs.Commands.ICommandPublisher`1"/> and <see cref="T:Cqrs.Commands.ICommandReceiver`1"/>)
            event bus
            (<see cref="T:Cqrs.Events.IEventPublisher`1"/> and <see cref="T:Cqrs.Events.IEventHandler`3"/>)
            as well as a <see cref="T:Cqrs.Bus.IEventHandlerRegistrar"/> and <see cref="T:Cqrs.Bus.ICommandHandlerRegistrar"/> that requires no networking.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.Routes">
            <summary>
            Gets or sets the Route Manager
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.AuthenticationTokenHelper">
            <summary>
            Gets or sets the Authentication Token Helper
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.CorrelationIdHelper">
            <summary>
            Gets or sets the CorrelationId Helper
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.DependencyResolver">
            <summary>
            Gets or sets the Dependency Resolver
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.Logger">
            <summary>
            Gets or sets the Logger
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.ConfigurationManager">
            <summary>
            Gets or sets the Configuration Manager
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.BusHelper">
            <summary>
            Gets or sets the Bus Helper
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.EventWaits">
            <summary>
            Gets or sets the current list of events waiting to be evaluated for <see cref="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.TelemetryHelper">
            <summary>
            Gets or sets the Telemetry Helper
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.#ctor(Cqrs.Authentication.IAuthenticationTokenHelper{`0},Chinchilla.Logging.ICorrelationIdHelper,Cqrs.Configuration.IDependencyResolver,Chinchilla.Logging.ILogger,Cqrs.Configuration.IConfigurationManager,Cqrs.Bus.IBusHelper)">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.Bus.InProcessBus`1"/> class.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PrepareCommand``1(``0)">
            <summary>
            Sets the
            <see cref="P:Cqrs.Messages.IMessageWithAuthenticationToken`1.AuthenticationToken"/>,
            <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/>,
            <see cref="P:Cqrs.Messages.IMessage.OriginatingFramework"/> to "Built-In" and
            adds a value of "Built-In" to the <see cref="P:Cqrs.Messages.IMessage.Frameworks"/>
            if not already done so
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PrepareAndValidateCommand``1(``0,Cqrs.Bus.RouteHandlerDelegate@)">
            <summary>
            Locates a suitable <see cref="T:Cqrs.Commands.ICommandValidator`2"/> to validate the provided <paramref name="command"/> and validates the provided <paramref name="command"/> if one is located
            Calls <see cref="M:Cqrs.Bus.InProcessBus`1.PrepareCommand``1(``0)"/>
            Checks if the provided <paramref name="command"/> is required to be processed
            Locates a single <see cref="T:Cqrs.Bus.RouteHandlerDelegate">command handler</see> for the provided <paramref name="command"/>
            </summary>
            <returns>
            False if a suitable <see cref="T:Cqrs.Commands.ICommandValidator`2"/> is located and the provided <paramref name="command"/> fails validation,
            False if no <see cref="T:Cqrs.Bus.RouteHandlerDelegate">command handler</see> is found but the command isn't required to be handled,
            True otherwise.
            </returns>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Cqrs#Commands#ICommandPublisher{TAuthenticationToken}#Publish``1(``0)">
            <summary>
            Publishes the provided <paramref name="command"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Send``1(``0)">
            <summary>
            Publishes the provided <paramref name="command"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Cqrs#Commands#ICommandPublisher{TAuthenticationToken}#Publish``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="commands"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Send``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="commands"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Publish``1(``0)">
            <summary>
            Publishes the provided <paramref name="event"/> on the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Publish``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="events"/> on the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.RegisterHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.RegisterGlobalEventHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event handler that will listen and respond to all events.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.ReceiveCommand(Cqrs.Commands.ICommand{`0})">
            <summary>
            Receives a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.ReceiveEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Receives an <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IStoreLastEventProcessed">
            <summary>
            Indicates the position in a store where the stream has been read up to.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.IStoreLastEventProcessed.EventLocation">
            <summary>
            The location within the store where the stream has been read up to.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.QueuedCommandBusReceiver`1">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus, places them into one of several internal concurrent queues and then processes the commands one at a time per queue.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker">
            <summary>
            The queues keyed by an identifier.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTrackerLock">
            <summary>
            A <see cref="T:System.Threading.ReaderWriterLockSlim"/> for providing a lock mechanism around the main <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.AuthenticationTokenHelper">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Authentication.IAuthenticationTokenHelper`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.CorrelationIdHelper">
            <summary>
            Gets or sets the <see cref="T:Chinchilla.Logging.ICorrelationIdHelper"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.Logger">
            <summary>
            Gets or sets the <see cref="T:Chinchilla.Logging.ILogger"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.ConfigurationManager">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IConfigurationManager"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.BusHelper">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Bus.IBusHelper"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.Routes">
            <summary>
            Gets or sets the routes or handlers that will be executed as the commands arrive.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.#ctor(Cqrs.Authentication.IAuthenticationTokenHelper{`0},Chinchilla.Logging.ICorrelationIdHelper,Chinchilla.Logging.ILogger,Cqrs.Configuration.IConfigurationManager,Cqrs.Bus.IBusHelper)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Bus.QueuedCommandBusReceiver`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.EnqueueCommand(System.String,Cqrs.Commands.ICommand{`0})">
            <summary>
            Places the provided <paramref name="command"/> into the appropriate queue in the <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>.
            </summary>
            <param name="targetQueueName">The name of the target queue to place the command into</param>
            <param name="command">The <see cref="T:Cqrs.Commands.ICommand`1"/> to handle.</param>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.CreateQueueAndAttachListenerIfNotExist(System.String)">
            <summary>
            Checks if the queue exists, if it doesn't it creates a new queue in <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/> and then starts a separate <see cref="T:System.Threading.Thread"/> running <see cref="M:Cqrs.Bus.QueuedCommandBusReceiver`1.DequeuAndProcessCommand(System.String)"/>.
            </summary>
            <param name="queueName">The name of the queue.</param>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.DequeuAndProcessCommand(System.String)">
            <summary>
            Infinitely runs a loop checking if the queue exists in <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>
            and then dequeues <see cref="T:Cqrs.Commands.ICommand`1"/> one at a time, pausing for 0.1 seconds between loops.
            </summary>
            <param name="queueName">The name of the queue.</param>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueCount">
            <summary>
            The current number of queues in <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueNames">
            <summary>
            Gets the names of all queues in <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.ReceiveCommand(Cqrs.Commands.ICommand{`0})">
            <summary>
            Receives a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.Start">
            <summary>
            Starts listening and processing instances of <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.Route">
            <summary>
            A collection of <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.Route.Handlers">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.RouteHandlerDelegate">
            <summary>
            Information about a <see cref="T:Cqrs.Bus.Route"/> delegate.
            </summary>
            <remarks>Remarkably similar to <see cref="T:Cqrs.Configuration.HandlerDelegate"/></remarks>
        </member>
        <member name="T:Cqrs.Bus.RouteManager">
            <summary>
            Manages <see cref="T:Cqrs.Bus.Route">routes</see>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.RouteManager.Routes">
            <summary>
            The <see cref="T:Cqrs.Bus.Route"/> to execute per <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.RouteManager.GlobalEventRoute">
            <summary>
            A <see cref="T:Cqrs.Bus.Route"/> to execute for all <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Bus.RouteManager"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.RegisterHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.RegisterGlobalEventHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event handler that will listen and respond to all events.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.GetSingleHandler``1(System.Boolean)">
            <summary>
            Gets the single <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> expected for handling <typeparamref name="TMessage"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for.</typeparam>
            <param name="throwExceptionOnNoRouteHandlers">If true will throw an <see cref="T:System.Exception"/> if no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> found.</param>
            <exception cref="T:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException">If more than one <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/>.</exception>
            <exception cref="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException">If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
            <exception cref="T:System.InvalidOperationException">
            If more than one <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not an <see cref="T:Cqrs.Commands.ICommand`1"/> OR
            If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.GetSingleHandler``1(``0,System.Boolean)">
            <summary>
            Gets the single <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> expected for handling <typeparamref name="TMessage"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for.</typeparam>
            <param name="message">The <typeparamref name="TMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for. </param>
            <param name="throwExceptionOnNoRouteHandlers">If true will throw an <see cref="T:System.Exception"/> if no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> found.</param>
            <exception cref="T:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException">If more than one <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/>.</exception>
            <exception cref="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException">If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
            <exception cref="T:System.InvalidOperationException">
            If more than one <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not an <see cref="T:Cqrs.Commands.ICommand`1"/> OR
            If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.GetHandlers``1(``0,System.Boolean)">
            <summary>
            Gets the collection <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> that are expected for handling <typeparamref name="TMessage"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for.</typeparam>
            <param name="message">The <typeparamref name="TMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for. </param>
            <param name="throwExceptionOnNoRouteHandlers">If true will throw an <see cref="T:System.Exception"/> if no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> found.</param>
            <exception cref="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException">If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
            <exception cref="T:Cqrs.Exceptions.NoEventHandlerRegisteredException"> If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Events.IEvent`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
            <exception cref="T:Cqrs.Exceptions.NoHandlerRegisteredException"> If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not either an <see cref="T:Cqrs.Commands.ICommand`1"/> or an <see cref="T:Cqrs.Events.IEvent`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.IsACommand``1(``0)">
            <summary>
            Checks if the provided <paramref name="message"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to check.</typeparam>
            <param name="message">The <typeparamref name="TMessage"/> to check. </param>
            <returns>true if <paramref name="message"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/>.</returns>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.IsACommand(System.Type)">
            <summary>
            Checks if the provided <paramref name="messageType"/> implements <see cref="T:Cqrs.Commands.ICommand`1"/>.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of object to check.</param>
            <returns>true if <paramref name="messageType"/> implements <see cref="T:Cqrs.Commands.ICommand`1"/>.</returns>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.IsAnEvent``1(``0)">
            <summary>
            Checks if the provided <paramref name="message"/> is an <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to check.</typeparam>
            <param name="message">The <typeparamref name="TMessage"/> to check. </param>
            <returns>true if <paramref name="message"/> is an <see cref="T:Cqrs.Events.IEvent`1"/>.</returns>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.IsAnEvent(System.Type)">
            <summary>
            Checks if the provided <paramref name="messageType"/> implements <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of object to check.</param>
            <returns>true if <paramref name="messageType"/> implements <see cref="T:Cqrs.Events.IEvent`1"/>.</returns>
        </member>
        <member name="T:Cqrs.Cache.CacheRepository`1">
            <summary>
            Uses <see cref="P:System.Runtime.Caching.MemoryCache.Default"/> to provide a caching mechanism to improve performance of a <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Cache.CacheRepository`1.Repository">
            <summary>
            Sets or set the <see cref="T:Cqrs.Domain.IAggregateRepository`1"/> that will be used, and cached over.
            </summary>
        </member>
        <member name="P:Cqrs.Cache.CacheRepository`1.EventStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Events.IEventStore`1"/> used to retrieve events from when a cache hit occurs.
            </summary>
        </member>
        <member name="P:Cqrs.Cache.CacheRepository`1.Cache">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Caching.MemoryCache"/> used.
            </summary>
        </member>
        <member name="M:Cqrs.Cache.CacheRepository`1.#ctor(Cqrs.Domain.IAggregateRepository{`0},Cqrs.Events.IEventStore{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Cache.CacheRepository`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Cache.CacheRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Locks the cache, adds the provided <paramref name="aggregate"/> to the cache if not already in it, then calls <see cref="M:Cqrs.Domain.IAggregateRepository`1.Save``1(``0,System.Nullable{System.Int32})"/> on <see cref="P:Cqrs.Cache.CacheRepository`1.Repository"/>.
            In the event of an <see cref="T:System.Exception"/> the <paramref name="aggregate"/> is always ejected out of the <see cref="P:Cqrs.Cache.CacheRepository`1.Cache"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Cache.CacheRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Locks the cache, checks if the aggregate is tracked in the <see cref="P:Cqrs.Cache.CacheRepository`1.Cache"/>, if it is
            retrieves the aggregate from the <see cref="P:Cqrs.Cache.CacheRepository`1.Cache"/> and then uses either the provided <paramref name="events"/> or makes a call <see cref="M:Cqrs.Events.IEventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)"/> on the <see cref="P:Cqrs.Cache.CacheRepository`1.EventStore"/>
            and rehydrates the cached aggregate with any new events from it's cached version.
            If the aggregate is not in the <see cref="P:Cqrs.Cache.CacheRepository`1.Cache"/>
            <see cref="M:Cqrs.Domain.IAggregateRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})"/> is called on the <see cref="P:Cqrs.Cache.CacheRepository`1.Repository"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The ID of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to get.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Cache.CacheRepository`1.GetToVersion``1(System.Guid,System.Int32,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/> up to and including the provided <paramref name="version"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="version">Load events up-to and including from this version</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Cache.CacheRepository`1.GetToDate``1(System.Guid,System.DateTime,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/> up to and including the provided <paramref name="versionedDate"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="T:Cqrs.Commands.CommandExtensions">
            <summary>
            A set of extension method for <see cref="T:Cqrs.Commands.ICommand`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.CommandExtensions.GetIdentity``1(Cqrs.Commands.ICommand{``0})">
            <summary>
            The identity of the target object of the provided <paramref name="command"/>.
            </summary>
            <param name="command">The <see cref="T:Cqrs.Commands.ICommand`1"/> to locate the identify from.</param>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
            <returns><see cref="P:Cqrs.Commands.ICommandWithIdentity`1.Rsn"/> or <see cref="P:Cqrs.Commands.ICommand`1.Id"/>.</returns>
        </member>
        <member name="T:Cqrs.Commands.DtoCommand`2">
            <summary>
            A <see cref="T:Cqrs.Commands.ICommand`1"/> for <see cref="T:Cqrs.Domain.IDto"/> objects
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TDto">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IDto"/> this command targets.</typeparam>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.Original">
            <summary>
            Gets or sets the original version of the <typeparamref name="TDto"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.New">
            <summary>
            Gets or sets the new version of the <typeparamref name="TDto"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.DtoCommand`2.#ctor(System.Guid,`1,`1)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Commands.DtoCommand`2"/>
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.Id">
            <summary>
            The identifier of the command itself.
            In some cases this may be the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> this command targets.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.ExpectedVersion">
            <summary>
            The expected version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.AuthenticationToken">
            <summary>
            The <typeparamref name="TAuthenticationToken"/> of the entity that triggered the event to be raised.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Commands.DtoCommand`2.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.OriginatingFramework">
            <summary>
            The originating framework this message was sent from.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.Frameworks">
            <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage"/> has been delivered to/sent via already.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.DtoCommandHandler`2">
            <summary>
            A <see cref="T:Cqrs.Commands.ICommandHandle"/> for working with <see cref="T:Cqrs.Commands.DtoCommand`2"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TDto">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IDto"/> this command targets.</typeparam>
        </member>
        <member name="M:Cqrs.Commands.DtoCommandHandler`2.#ctor(Cqrs.Domain.IUnitOfWork{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Commands.DtoCommandHandler`2"/>
            </summary>
        </member>
        <member name="M:Cqrs.Commands.DtoCommandHandler`2.Handle(Cqrs.Commands.DtoCommand{`0,`1})">
            <summary>
            Responds to the provided <paramref name="message"/>.
            </summary>
            <param name="message">The <see cref="T:Cqrs.Commands.DtoCommand`2"/> to respond to or "handle"</param>
        </member>
        <member name="T:Cqrs.Commands.ICommand`1">
            <summary>
            People request changes to the domain by sending <see cref="T:Cqrs.Commands.ICommand`1"/>s. They are named with a verb in the imperative mood plus and may include the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> type, for example ConfirmOrder. Unlike an <see cref="T:Cqrs.Events.IEvent`1"/>, a <see cref="T:Cqrs.Commands.ICommand`1"/> is not a statement of fact; it's only a request, and thus may be refused. (A typical way to convey refusal is to raise a specifically typed <see cref="T:Cqrs.Events.IEvent`1"/> stating the <see cref="T:Cqrs.Commands.ICommand`1"/> didn't happen for a specific reason).
            </summary>
            <example>
            public class ConfirmOrder
            {
            	public Guid OrderRsn;
            }
            </example>
            <remarks>
            What does a <see cref="T:Cqrs.Commands.ICommand`1"/> or an <see cref="T:Cqrs.Events.IEvent`1"/> look like?
            
            An <see cref="T:Cqrs.Commands.ICommand`1"/> or <see cref="T:Cqrs.Events.IEvent`1"/> is simply a data structure that contain data for reading, and no behavior. We call such structures "Data Transfer Objects" (DTOs). The name indicates the purpose. In many languages they are represented as classes, but they are not true classes in the real OO sense.
            
            
            What is the difference between a <see cref="T:Cqrs.Commands.ICommand`1"/> and an <see cref="T:Cqrs.Events.IEvent`1"/>?
            
            Their intent.
            
            
            What is immutability? Why is a <see cref="T:Cqrs.Commands.ICommand`1"/> or <see cref="T:Cqrs.Events.IEvent`1"/> immutable?
            
            For the purpose of this question, immutability is not having any setters, or other methods which change internal state. The <see cref="T:System.String"/> type in is a familiar example; you never actually change an existing <see cref="T:System.String"/> value, you just create new <see cref="T:System.String"/> values based on old ones.
            
            An <see cref="T:Cqrs.Commands.ICommand`1"/> is immutable because their expected usage is to be sent directly to the domain model side for processing. They do not need to change during their projected lifetime in traveling from client to server.
            Sometimes however business logic dictates that a decision may be made to construct a <see cref="T:Cqrs.Commands.ICommand`1"/> and local variables should be used.
            
            An <see cref="T:Cqrs.Events.IEvent`1"/> is immutable because they represent domain actions that took place in the past. Unless you're Marty McFly, you can't change the past, and sometimes not even then.
            
            
            What is command upgrading?
            
            Upgrading an <see cref="T:Cqrs.Commands.ICommand`1"/> becomes necessary when new requirements cause an existing <see cref="T:Cqrs.Commands.ICommand`1"/> not to be sufficient. Maybe a new field needs to be added, for example, or maybe an existing field should really have been split into several different ones.
            
            
            How do I upgrade my <see cref="T:Cqrs.Commands.ICommand`1"/>s?
            
            How you do the upgrade depends how much control you have over your clients. If you can deploy your client updates and server updates together, just change things in both and deploy the updates. Job done. If not, it's usually best to have the updated <see cref="T:Cqrs.Commands.ICommand`1"/> be a new type and have the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> accept both for a while.
            
            
            Could you give an example of names of some versioned <see cref="T:Cqrs.Commands.ICommand`1"/>?
            
            Sure.
            
            UploadFile
            UploadFile_v2
            UploadFile_v3
            
            It's just a convention, but a sane one.
            ********************************************
            Also see http://cqrs.nu/Faq/commands-and-events.
            </remarks>
        </member>
        <member name="P:Cqrs.Commands.ICommand`1.Id">
            <summary>
            The identifier of the command itself.
            In some cases this may be the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> this command targets.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.ICommand`1.ExpectedVersion">
            <summary>
            The expected version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.ICommandHandler`2">
            <summary>
            An <see cref="T:Cqrs.Commands.ICommandHandler`2"/> receives an <see cref="T:Cqrs.Commands.ICommand`1"/> and brokers a result from the appropriate <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            "A result" is either a successful application of the command, or an exception.
            This is the common sequence of steps an <see cref="T:Cqrs.Commands.ICommandHandler`2"/> might follow:
            
            Validate the <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits.
            Ask an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to handle the <see cref="T:Cqrs.Commands.ICommand`1"/>.
            If validation is successful, 0..n <see cref="T:Cqrs.Events.IEvent`1"/> artefacts (1 is common) are queued for publishing.
            Attempt to persist the new <see cref="T:Cqrs.Events.IEvent`1"/> artefacts. If there's a concurrency conflict during this step, either give up, or retry things.
            Dispatch the queued <see cref="T:Cqrs.Events.IEvent`1"/> artefacts.
            </summary>
            <remarks>
            Should a <see cref="T:Cqrs.Commands.ICommandHandler`2"/> affect one or several <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>s?
            
            Only one.
            
            
            Do I put logic in <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            Yes. Exactly what logic depends on your factoring.
            The logic for validating the <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits always gets executed in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>, although we recommend refactoring these into an <see cref="T:Cqrs.Commands.ICommandValidator`2"/>.
            Provided validation is successful we recommend a more functional factoring, where the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> exists independently of the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> and the next step would be to load the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> and request the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> handle the <see cref="T:Cqrs.Commands.ICommand`1"/> itself.
            The <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> should then have uncommitted <see cref="T:Cqrs.Events.IEvent`1"/> artefacts as a results of asking the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to handle the <see cref="T:Cqrs.Commands.ICommand`1"/>.
            Finally the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> should instruct the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> to <see cref="M:Cqrs.Domain.IUnitOfWork`1.Commit"/> all uncommited <see cref="T:Cqrs.Events.IEvent`1"/> artefacts.
            
            However you have it, the logic boils down to validation and some sequence of steps that lead to the <see cref="T:Cqrs.Commands.ICommand`1"/> becoming an <see cref="T:System.Exception"/> or <see cref="T:Cqrs.Events.IEvent`1"/>(s). If you're tempted to go beyond this, see the rest of the remarks.
            
            
            Can I call a read side (such as a read store, data store or <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>) from my <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            No.
            
            
            Can I do logging, security, or auditing in my <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            Yes. The decorator pattern comes in handy here to separate those concerns neatly.
            
            
            How are conflicts between concurrent <see cref="T:Cqrs.Commands.ICommand`1"/>s handled in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            The place where the new <see cref="T:Cqrs.Events.IEvent`1"/> artefacts for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are persisted is the only place in the system where we need to worry about concurrency conflicts. The <see cref="T:Cqrs.Events.IEventStore`1"/> knows the sequence number of the latest <see cref="T:Cqrs.Events.IEvent`1"/> applied on that <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>, and the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> knows the sequence number of the last <see cref="T:Cqrs.Events.IEvent`1"/> it read. If these numbers do not agree, it means some other thread or process got there first. The <see cref="T:Cqrs.Commands.ICommandHandler`2"/> can then load up the events again and make a new attempt.
            
            
            Should I do things that have side-effects in the outside world (such as sending email) directly in a <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            No, since a concurrency conflict will mean the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> logic will be run again. Do such things in an Apply <see cref="T:Cqrs.Events.IEvent`1"/> method in an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            ********************************************
            Also see http://cqrs.nu/Faq/command-handlers.
            </remarks>
        </member>
        <member name="T:Cqrs.Commands.ICommandHandle">
            <summary>
            An <see cref="T:Cqrs.Commands.ICommandHandler`2"/> receives an <see cref="T:Cqrs.Commands.ICommand`1"/> and brokers a result from the appropriate <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            "A result" is either a successful application of the command, or an exception.
            This is the common sequence of steps an <see cref="T:Cqrs.Commands.ICommandHandler`2"/> might follow:
            
            Validate the <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits.
            Ask an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to handle the <see cref="T:Cqrs.Commands.ICommand`1"/>.
            If validation is successful, 0..n <see cref="T:Cqrs.Events.IEvent`1"/> artefacts (1 is common) are queued for publishing.
            Attempt to persist the new <see cref="T:Cqrs.Events.IEvent`1"/> artefacts. If there's a concurrency conflict during this step, either give up, or retry things.
            Dispatch the queued <see cref="T:Cqrs.Events.IEvent`1"/> artefacts.
            </summary>
            <remarks>
            Should a <see cref="T:Cqrs.Commands.ICommandHandler`2"/> affect one or several <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>s?
            
            Only one.
            
            
            Do I put logic in <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            Yes. Exactly what logic depends on your factoring.
            The logic for validating the <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits always gets executed in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>, although we recommend refactoring these into an <see cref="T:Cqrs.Commands.ICommandValidator`2"/>.
            Provided validation is successful we recommend a more functional factoring, where the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> exists independently of the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> and the next step would be to load the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> and request the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> handle the <see cref="T:Cqrs.Commands.ICommand`1"/> itself.
            The <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> should then have uncommitted <see cref="T:Cqrs.Events.IEvent`1"/> artefacts as a results of asking the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to handle the <see cref="T:Cqrs.Commands.ICommand`1"/>.
            Finally the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> should instruct the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> to <see cref="M:Cqrs.Domain.IUnitOfWork`1.Commit"/> all uncommited <see cref="T:Cqrs.Events.IEvent`1"/> artefacts.
            
            However you have it, the logic boils down to validation and some sequence of steps that lead to the <see cref="T:Cqrs.Commands.ICommand`1"/> becoming an <see cref="T:System.Exception"/> or <see cref="T:Cqrs.Events.IEvent`1"/>(s). If you're tempted to go beyond this, see the rest of the remarks.
            
            
            Can I call a read side (such as a read store, data store or <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>) from my <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            No.
            
            
            Can I do logging, security, or auditing in my <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            Yes. The decorator pattern comes in handy here to separate those concerns neatly.
            
            
            How are conflicts between concurrent <see cref="T:Cqrs.Commands.ICommand`1"/>s handled in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            The place where the new <see cref="T:Cqrs.Events.IEvent`1"/> artefacts for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are persisted is the only place in the system where we need to worry about concurrency conflicts. The <see cref="T:Cqrs.Events.IEventStore`1"/> knows the sequence number of the latest <see cref="T:Cqrs.Events.IEvent`1"/> applied on that <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>, and the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> knows the sequence number of the last <see cref="T:Cqrs.Events.IEvent`1"/> it read. If these numbers do not agree, it means some other thread or process got there first. The <see cref="T:Cqrs.Commands.ICommandHandler`2"/> can then load up the events again and make a new attempt.
            
            
            Should I do things that have side-effects in the outside world (such as sending email) directly in a <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            No, since a concurrency conflict will mean the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> logic will be run again. Do such things in an Apply <see cref="T:Cqrs.Events.IEvent`1"/> method in an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            ********************************************
            Also see http://cqrs.nu/Faq/command-handlers.
            </remarks>
        </member>
        <member name="T:Cqrs.Commands.ICommandPublisher`1">
            <summary>
            Publishes an <see cref="T:Cqrs.Commands.ICommand`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandPublisher`1.Publish``1(``0)">
            <summary>
            Publishes the provided <paramref name="command"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandPublisher`1.Publish``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="commands"/> on the command bus.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.ICommandReceiver">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandReceiver.Start">
            <summary>
            Starts listening and processing instances of <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.ICommandReceiver`1">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Commands.ICommandReceiver`1.ReceiveCommand(Cqrs.Commands.ICommand{`0})">
            <summary>
            Receives a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.ICommandValidator`2">
            <summary>
            Validates an <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandValidator`2.IsCommandValid(`1)">
            <summary>
            Validates the provided <param name="command" /> on its own merits.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.ICommandWithIdentity`1">
            <summary>
            An <see cref="T:Cqrs.Commands.ICommand`1"/> that can identify an <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see>.
            The <see cref="P:Cqrs.Commands.ICommand`1.Id"/> is specifically the identifier for the individual <see cref="T:Cqrs.Commands.ICommand`1"/> itself, not the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Commands.ICommandWithIdentity`1.Rsn">
            <summary>
            The identity of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.IPublishAndWaitCommandPublisher`1">
            <summary>
            Publishes an <see cref="T:Cqrs.Commands.ICommand`1"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="T:Cqrs.Commands.ISendAndWaitCommandSender`1">
            <summary>
            Sends an <see cref="T:Cqrs.Commands.ICommand`1"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
        </member>
        <member name="T:Cqrs.Configuration.BusRegistrar">
            <summary>
            Triggers the <see cref="T:Cqrs.Bus.IEventHandlerRegistrar"/> and <see cref="T:Cqrs.Bus.ICommandHandlerRegistrar"/> if they are registered in the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.BusRegistrar.DependencyResolver">
            <summary>
            Gets or set the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.BusRegistrar.GetEventHandlerRegistrar">
            <summary>
            A <see cref="T:System.Func`3"/> to use in-place of <see cref="T:Cqrs.Bus.IEventHandlerRegistrar"/>
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.BusRegistrar.GetCommandHandlerRegistrar">
            <summary>
            A <see cref="T:System.Func`3"/> to use in-place of <see cref="T:Cqrs.Bus.ICommandHandlerRegistrar"/>
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.#ctor(Cqrs.Configuration.IDependencyResolver)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Configuration.BusRegistrar"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.Register(System.Type[])">
            <summary>
            Registers all <see cref="T:Cqrs.Events.IEventHandler"/> and <see cref="T:Cqrs.Commands.ICommandHandler`2"/> instances found in the <see cref="T:System.Reflection.Assembly"/> for each <see cref="T:System.Type"/> in <paramref name="typesFromAssemblyContainingMessages"/>.
            </summary>
            <param name="typesFromAssemblyContainingMessages">A collection of <see cref="T:System.Type"/> to track back to their containing <see cref="T:System.Reflection.Assembly"/> and scan.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.Register(System.Boolean,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}},System.Boolean,System.Type[])">
            <summary>
            Registers all <see cref="T:Cqrs.Messages.IHandler"/> instances found in the <see cref="T:System.Reflection.Assembly"/> for each <see cref="T:System.Type"/> in <paramref name="typesFromAssemblyContainingMessages"/>.
            </summary>
            <param name="trueForEventsFalseForCommands">Indicates if this is registers <see cref="T:Cqrs.Events.IEventHandler"/> or <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
            <param name="resolveMessageHandlerInterface"><see cref="M:Cqrs.Configuration.BusRegistrar.ResolveEventHandlerInterface(System.Type)"/> or <see cref="M:Cqrs.Configuration.BusRegistrar.ResolveCommandHandlerInterface(System.Type)"/></param>
            <param name="skipCommandHandlers">Indicates if registering of <see cref="T:Cqrs.Commands.ICommandHandler`2"/> is enabled.</param>
            <param name="typesFromAssemblyContainingMessages">A collection of <see cref="T:System.Type"/> to track back to their containing <see cref="T:System.Reflection.Assembly"/> and scan.</param>
        </member>
        <member name="T:Cqrs.Configuration.BusRegistrar.HandlerTypeInformation">
            <summary>
            Information explaining the registration to make
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.BusRegistrar.HandlerTypeInformation.Type">
            <summary>
            The <see cref="P:Cqrs.Configuration.BusRegistrar.HandlerTypeInformation.Type"/> of the hanlder to register
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.BusRegistrar.HandlerTypeInformation.Interfaces">
            <summary>
            The Handler type to resolve to, so either <see cref="T:Cqrs.Events.IEventHandler`2"/> or <see cref="T:Cqrs.Commands.ICommandHandler`2"/>
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.Register(System.Boolean,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}},System.Boolean,Cqrs.Configuration.BusRegistrar.HandlerTypeInformation[])">
            <summary>
            Registers all <see cref="T:Cqrs.Messages.IHandler"/> instances in the provided <paramref name="executorTypes"/>.
            </summary>
            <param name="trueForEventsFalseForCommands">Indicates if this is registers <see cref="T:Cqrs.Events.IEventHandler"/> or <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
            <param name="resolveMessageHandlerInterface"><see cref="M:Cqrs.Configuration.BusRegistrar.ResolveEventHandlerInterface(System.Type)"/> or <see cref="M:Cqrs.Configuration.BusRegistrar.ResolveCommandHandlerInterface(System.Type)"/></param>
            <param name="skipCommandHandlers">Indicates if registering of <see cref="T:Cqrs.Commands.ICommandHandler`2"/> is enabled.</param>
            <param name="executorTypes">A collection of <see cref="T:System.Type"/> to register.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.InvokeHandler(System.Type,System.Boolean,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}},System.Type)">
            <summary>
            Extract the <see cref="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)"/> method of <see cref="P:Cqrs.Configuration.BusRegistrar.GetEventHandlerRegistrar"/> or <see cref="P:Cqrs.Configuration.BusRegistrar.GetCommandHandlerRegistrar"/>.
            Create an <see cref="T:System.Action"/> around the provided <paramref name="executorType"/>
            Then register the created <see cref="T:System.Action"/> using the extracted <see cref="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)"/> method
            </summary>
            <param name="interface">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IHandler"/></param>
            <param name="trueForEventsFalseForCommands">Indicates if this is registers <see cref="T:Cqrs.Events.IEventHandler"/> or <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
            <param name="resolveMessageHandlerInterface"><see cref="M:Cqrs.Configuration.BusRegistrar.ResolveEventHandlerInterface(System.Type)"/> or <see cref="M:Cqrs.Configuration.BusRegistrar.ResolveCommandHandlerInterface(System.Type)"/></param>
            <param name="executorType">The <see cref="T:System.Type"/> of the event handler that will do the handling</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.InvokeHandlerDelegate(System.Reflection.MethodInfo,System.Boolean,Cqrs.Configuration.HandlerDelegate)">
            <summary>
            Invokes <paramref name="handlerDelegate"/>, fetching the corresponding "HoldMessageLock" configuration setting 
            </summary>
            <param name="registerExecutorMethod">The <see cref="T:System.Reflection.MethodInfo"/> to use to invoke <paramref name="handlerDelegate"/>.</param>
            <param name="trueForEventsFalseForCommands">Indicates if this is registers <see cref="T:Cqrs.Events.IEventHandler"/> or <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
            <param name="handlerDelegate">The actual <see cref="T:Cqrs.Configuration.HandlerDelegate"/> that gets executed.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.BuildDelegateAction(System.Type,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            Builds a <see cref="T:Cqrs.Configuration.HandlerDelegate"/> that will resolve the provided <paramref name="executorType"/> and invoke the Handle method, when executed.
            </summary>
            <param name="executorType">The type of <see cref="T:Cqrs.Messages.IHandler"/> to resolve.></param>
            <param name="resolveMessageHandlerInterface">Not used.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.BuildExecutorMethod(System.Reflection.MethodInfo,System.Type,System.Type)">
            <summary>
            Builds a method replacing the generic type with <paramref name="commandType"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.ResolveEventHandlerInterface(System.Type)">
            <summary>
            Finds all <see cref="T:System.Type"/> that implement <see cref="T:Cqrs.Events.IEventHandler`2"/> that are implemented by <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find all <see cref="T:Cqrs.Events.IEventHandler`2"/> of.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.ResolveCommandHandlerInterface(System.Type)">
            <summary>
            Finds all <see cref="T:System.Type"/> that implement <see cref="T:Cqrs.Commands.ICommandHandler`2"/> that are implemented by <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find all <see cref="T:Cqrs.Commands.ICommandHandler`2"/> of.</param>
        </member>
        <member name="T:Cqrs.Configuration.ConfigurationExtensions">
            <summary>
            A collection of extension methods for <see cref="T:Cqrs.Configuration.IConfigurationManager"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.ConfigurationExtensions.GetExecutionPath">
            <summary>
            Get or Set the <see cref="T:System.Func`1"/> that returns the path to the where the execution is occuring.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationExtensions.CreateTelemetryHelper(Cqrs.Configuration.IConfigurationManager,System.String,Cqrs.Configuration.IDependencyResolver)">
            <summary>
            Creates an instance of <see cref="T:Chinchilla.Logging.ITelemetryHelper"/> if the value for <paramref name="configurationKey"/> is true.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationExtensions.CreateTelemetryHelper(Cqrs.Configuration.IConfigurationManager,System.String,Chinchilla.Logging.ICorrelationIdHelper)">
            <summary>
            Creates an instance of <see cref="T:Chinchilla.Logging.ITelemetryHelper"/> if the value for <paramref name="configurationKey"/> is true.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.ConfigurationManager">
            <summary>
            Provides access to configuration settings from the app settings of an app.config or web.config... i.e. <see cref="P:System.Configuration.ConfigurationManager.AppSettings"/>
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationManager.GetSetting(System.String)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationManager.TryGetSetting(System.String,System.String@)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the an element with the specified key exists; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationManager.TryGetSetting(System.String,System.Boolean@)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the an element with the specified key exists; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationManager.GetConnectionString(System.String)">
            <summary>
            Read the configuration string named <paramref name="connectionStringName"/>.
            </summary>
            <param name="connectionStringName">The name (or key) of the connection string to read.</param>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationManager.GetConnectionStringBySettingKey(System.String,System.Boolean,System.Boolean)">
            <summary>
            Read the configuration string where the name (or key) of the connection string is stored in a setting, first obtained with a call to <see cref="M:Cqrs.Configuration.ConfigurationManager.GetSetting(System.String)"/>
            </summary>
            <param name="key">The key (or name) of the setting that has the name (or key) of the connection string to read.</param>
            <param name="throwIfKeyMissing">If true, will throw a <see cref="T:Cqrs.Exceptions.MissingApplicationSettingForConnectionStringException"/> if no application setting with the provided <paramref name="key"/> is found.</param>
            <param name="throwIfConnectionstringMissing">If true, will throw a <see cref="T:Cqrs.Exceptions.MissingConnectionStringException"/> if no connection string is found.</param>
        </member>
        <member name="T:Cqrs.Configuration.DependencyResolver">
            <summary>
            Provides an ability to resolve instances of objects.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.DependencyResolver.Current">
            <summary>
            The current instance of the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.DependencyResolver.Resolve``1">
            <summary>
            Resolves a single instance for the specified <typeparamref name="T"/>.
            Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of object you want to resolve.</typeparam>
            <returns>An instance of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Cqrs.Configuration.DependencyResolver.Resolve(System.Type)">
            <summary>
            Resolves a single instance for the specified <paramref name="type"/>.
            Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of object you want to resolve.</param>
            <returns>An instance of type <paramref name="type"/>.</returns>
        </member>
        <member name="T:Cqrs.Configuration.HandlerDelegate">
            <summary>
            Information about a <see cref="T:Cqrs.Messages.IHandler"/> delegate.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.HandlerDelegate`1">
            <summary>
            Information about a delegate.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.HandlerDelegate`1.Delegate">
            <summary>
            The delegate that gets executed.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.HandlerDelegate`1.TargetedType">
            <summary>
            The <see cref="T:System.Type"/> of the targeted object that <see cref="P:Cqrs.Configuration.HandlerDelegate`1.Delegate"/> operates on.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.IConfigurationManager">
            <summary>
            Provides access to configuration settings.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.IConfigurationManager.GetSetting(System.String)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
        </member>
        <member name="M:Cqrs.Configuration.IConfigurationManager.TryGetSetting(System.String,System.String@)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the an element with the specified key exists; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Configuration.IConfigurationManager.TryGetSetting(System.String,System.Boolean@)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the an element with the specified key exists; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Configuration.IConfigurationManager.GetConnectionString(System.String)">
            <summary>
            Read the configuration string named <paramref name="connectionStringName"/>.
            </summary>
            <param name="connectionStringName">The name (or key) of the connection string to read.</param>
        </member>
        <member name="M:Cqrs.Configuration.IConfigurationManager.GetConnectionStringBySettingKey(System.String,System.Boolean,System.Boolean)">
            <summary>
            Read the configuration string where the name (or key) of the connection string is stored in a setting, first obtained with a call to <see cref="M:Cqrs.Configuration.IConfigurationManager.GetSetting(System.String)"/>
            </summary>
            <param name="key">The key (or name) of the setting that has the name (or key) of the connection string to read.</param>
            <param name="throwIfKeyMissing">If true, will throw a <see cref="T:Cqrs.Exceptions.MissingApplicationSettingForConnectionStringException"/> if no application setting with the provided <paramref name="key"/> is found.</param>
            <param name="throwIfConnectionstringMissing">If true, will throw a <see cref="T:Cqrs.Exceptions.MissingConnectionStringException"/> if no connection string is found.</param>
        </member>
        <member name="T:Cqrs.Configuration.IDependencyResolver">
            <summary>
            Provides an ability to resolve instances of objects.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.IDependencyResolver.Resolve``1">
            <summary>
            Resolves a single instance for the specified <typeparamref name="T"/>.
            Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of object you want to resolve.</typeparam>
            <returns>An instance of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Cqrs.Configuration.IDependencyResolver.Resolve(System.Type)">
            <summary>
            Resolves a single instance for the specified <paramref name="type"/>.
            Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of object you want to resolve.</param>
            <returns>An instance of type <paramref name="type"/>.</returns>
        </member>
        <member name="T:Cqrs.Configuration.ITelemetryHelperExtensions">
            <summary>
            A collection of extension methods for <see cref="T:Chinchilla.Logging.ITelemetryHelper"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.ITelemetryHelperExtensions.TrackRequest``1(Chinchilla.Logging.ITelemetryHelper,System.String,``0,System.DateTimeOffset,System.TimeSpan,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send information about a request handled by the application.
            </summary>
            <param name="telemetryHelper">The <see cref="T:Chinchilla.Logging.ITelemetryHelper"/> being extended.s</param>
            <param name="name">The request name.</param>
            <param name="token">The token with user identifiable information.</param>
            <param name="startTime">The time when the page was requested.</param>
            <param name="duration">The time taken by the application to handle the request.</param>
            <param name="responseCode">The response status code.</param>
            <param name="wasSuccessfull">True if the request was handled successfully by the application.</param>
            <param name="properties">Named string values you can use to search and classify events.</param>
        </member>
        <member name="M:Cqrs.Configuration.ITelemetryHelperExtensions.TrackRequest(Chinchilla.Logging.ITelemetryHelper,System.String,System.Nullable{System.Guid},System.DateTimeOffset,System.TimeSpan,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send information about a request handled by the application.
            </summary>
            <param name="telemetryHelper">The <see cref="T:Chinchilla.Logging.ITelemetryHelper"/> being extended.s</param>
            <param name="name">The request name.</param>
            <param name="token">The token with user identifiable information.</param>
            <param name="startTime">The time when the page was requested.</param>
            <param name="duration">The time taken by the application to handle the request.</param>
            <param name="responseCode">The response status code.</param>
            <param name="wasSuccessfull">True if the request was handled successfully by the application.</param>
            <param name="properties">Named string values you can use to search and classify events.</param>
        </member>
        <member name="M:Cqrs.Configuration.ITelemetryHelperExtensions.TrackRequest(Chinchilla.Logging.ITelemetryHelper,System.String,System.Nullable{System.Int32},System.DateTimeOffset,System.TimeSpan,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send information about a request handled by the application.
            </summary>
            <param name="telemetryHelper">The <see cref="T:Chinchilla.Logging.ITelemetryHelper"/> being extended.s</param>
            <param name="name">The request name.</param>
            <param name="token">The token with user identifiable information.</param>
            <param name="startTime">The time when the page was requested.</param>
            <param name="duration">The time taken by the application to handle the request.</param>
            <param name="responseCode">The response status code.</param>
            <param name="wasSuccessfull">True if the request was handled successfully by the application.</param>
            <param name="properties">Named string values you can use to search and classify events.</param>
        </member>
        <member name="M:Cqrs.Configuration.ITelemetryHelperExtensions.TrackRequest(Chinchilla.Logging.ITelemetryHelper,System.String,System.String,System.DateTimeOffset,System.TimeSpan,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send information about a request handled by the application.
            </summary>
            <param name="telemetryHelper">The <see cref="T:Chinchilla.Logging.ITelemetryHelper"/> being extended.s</param>
            <param name="name">The request name.</param>
            <param name="token">The token with user identifiable information.</param>
            <param name="startTime">The time when the page was requested.</param>
            <param name="duration">The time taken by the application to handle the request.</param>
            <param name="responseCode">The response status code.</param>
            <param name="wasSuccessfull">True if the request was handled successfully by the application.</param>
            <param name="properties">Named string values you can use to search and classify events.</param>
        </member>
        <member name="T:Cqrs.Configuration.SampleRuntime`2">
            <summary>
            A sample runtime to use in proof of concept projects to get something running very quickly. Doesn't save anything. All data is lost when recycled and may cause terrible memory usage.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TCommandHanderOrEventHandler">The <see cref="T:System.Type"/> of any <see cref="T:Cqrs.Commands.ICommandHandle"/> or <see cref="T:Cqrs.Events.IEventHandler"/>.</typeparam>
        </member>
        <member name="P:Cqrs.Configuration.SampleRuntime`2.EventStoreCreator">
            <summary>
            The <see cref="T:System.Func`1"/> used to create the <see cref="T:Cqrs.Events.IEventStore`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.SampleRuntime`2.CustomResolver">
            <summary>
            A custom dependency resolver.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.#ctor">
            <summary>
            Instaiance a new instance of the <see cref="T:Cqrs.Configuration.SampleRuntime`2"/>
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.SetEventStoreCreator">
            <summary>
            Sets the <see cref="P:Cqrs.Configuration.SampleRuntime`2.EventStoreCreator"/> to use <see cref="T:Cqrs.Events.InProcessEventStore`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.StartDependencyResolver">
            <summary>
            Starts the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.RegisterHandlers">
            <summary>
            Registers the all <see cref="T:Cqrs.Events.IEventHandler"/> and <see cref="T:Cqrs.Commands.ICommandHandle"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.PrintStatsticsToConsole">
            <summary>
            Prints out the statistics of this run such as the number of event raised to the <see cref="T:System.Console"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.SampleRuntime`2.MockDependencyResolver">
            <summary>
            Provides an ability to resolve a minimum known set of objects.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.MockDependencyResolver.Start">
            <summary>
            Starts the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.MockDependencyResolver.Resolve``1">
            <summary>
            Resolves a single instance for the specified <typeparamref name="T"/>.
                        Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of object you want to resolve.</typeparam>
            <returns>
            An instance of type <typeparamref name="T"/>.
            </returns>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.MockDependencyResolver.Resolve(System.Type)">
            <summary>
            Resolves a single instance for the specified <paramref name="type"/>.
                        Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of object you want to resolve.</param>
            <returns>
            An instance of type <paramref name="type"/>.
            </returns>
        </member>
        <member name="M:Cqrs.Configuration.SampleRuntime`2.MockDependencyResolver.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.SqlSampleRuntime`2">
            <summary>
            A <see cref="T:Cqrs.Configuration.SampleRuntime`2"/> that uses SQL Server.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TCommandHanderOrEventHandler">The <see cref="T:System.Type"/> of any <see cref="T:Cqrs.Commands.ICommandHandle"/> or <see cref="T:Cqrs.Events.IEventHandler"/>.</typeparam>
        </member>
        <member name="M:Cqrs.Configuration.SqlSampleRuntime`2.SetEventStoreCreator">
            <summary>
            Sets the <see cref="P:Cqrs.Configuration.SampleRuntime`2.EventStoreCreator"/> to use <see cref="T:Cqrs.Events.InProcessEventStore`1"/>
            </summary>
        </member>
        <member name="T:Cqrs.DataStores.IDataStore`1">
            <summary>
            A data store capable of being queried and modified.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Add(`0)">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Remove(`0)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft) deleted by setting <see cref="P:Cqrs.Entities.Entity.IsDeleted"/> to true in the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Destroy(`0)">
            <summary>
            Remove the provided <paramref name="data"/> (normally by <see cref="P:Cqrs.Entities.IEntity.Rsn"/>) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.RemoveAll">
            <summary>
            Remove all contents (normally by use of a truncate operation) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Update(`0)">
            <summary>
            Update the provided <paramref name="data"/> in the data store and persist the change.
            </summary>
        </member>
        <member name="T:Cqrs.DataStores.InProcessDataStore`1">
            <summary>
            A <see cref="T:Cqrs.DataStores.IDataStore`1"/> using an <see cref="P:Cqrs.DataStores.InProcessDataStore`1.InMemoryDatabase"/>.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.#ctor">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.DataStores.InProcessDataStore`1"/> class
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.InProcessDataStore`1.Expression">
            <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable"/>.
            </summary>
            <returns>
            The <see cref="T:System.Linq.Expressions.Expression"/> that is associated with this instance of <see cref="T:System.Linq.IQueryable"/>.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.InProcessDataStore`1.ElementType">
            <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable"/> is executed.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.InProcessDataStore`1.Provider">
            <summary>
            Gets the singleResultQuery provider that is associated with this data source.
            </summary>
            <returns>
            The <see cref="T:System.Linq.IQueryProvider"/> that is associated with this data source.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Add(`0)">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Remove(`0)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft) deleted by setting <see cref="P:Cqrs.Entities.Entity.IsDeleted"/> to true in the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Destroy(`0)">
            <summary>
            Remove the provided <paramref name="data"/> (normally by <see cref="P:Cqrs.Entities.IEntity.Rsn"/>) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.RemoveAll">
            <summary>
            Remove all contents (normally by use of a truncate operation) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Update(`0)">
            <summary>
            Update the provided <paramref name="data"/> in the data store and persist the change.
            </summary>
        </member>
        <member name="T:Cqrs.DataStores.LinqToSqlDataStore`1">
            <summary>
            A <see cref="T:Cqrs.DataStores.IDataStore`1"/> using simplified SQL.
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.ConfigurationManager">
            <summary />
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.#ctor(Cqrs.Configuration.IConfigurationManager,Chinchilla.Logging.ILogger)">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.DataStores.LinqToSqlDataStore`1"/> class
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.DbDataContext">
            <summary>
            Gets or sets the DataContext.
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.WriteableConnectionStrings">
            <summary>
            Gets or sets the list of writeable connection strings for data mirroring
            </summary>
        </member>
        <member name="F:Cqrs.DataStores.LinqToSqlDataStore`1._writeableConnections">
            <summary>
            Gets or sets the list of writeable DataContexts for data mirroring
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.WriteableConnections">
            <summary>
            Gets or sets the list of writeable DataContexts for data mirroring
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.Table">
            <summary>
            Gets or sets the readable Table
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.Logger">
            <summary>
            Gets or sets the Logger
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.CreateDbDataContext">
            <summary>
            Locate the connection settings and create a <see cref="T:System.Data.Linq.DataContext"/>.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.GetWriteableConnectionStrings">
            <summary>
            Locate the connection settings for persisting data.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.Expression">
            <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable"/>.
            </summary>
            <returns>
            The <see cref="T:System.Linq.Expressions.Expression"/> that is associated with this instance of <see cref="T:System.Linq.IQueryable"/>.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.ElementType">
            <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable"/> is executed.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.LinqToSqlDataStore`1.Provider">
            <summary>
            Gets the query provider that is associated with this data source.
            </summary>
            <returns>
            The <see cref="T:System.Linq.IQueryProvider"/> that is associated with this data source.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.Add(`0)">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.Remove(`0)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft) deleted by setting <see cref="P:Cqrs.Entities.Entity.IsDeleted"/> to true in the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.Destroy(`0)">
            <summary>
            Remove the provided <paramref name="data"/> (normally by <see cref="P:Cqrs.Entities.IEntity.Rsn"/>) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.RemoveAll">
            <summary>
            Remove all contents (normally by use of a truncate operation) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlDataStore`1.Update(`0)">
            <summary>
            Update the provided <paramref name="data"/> in the data store and persist the change.
            </summary>
        </member>
        <member name="T:Cqrs.DataStores.LinqToSqlSqlDataStoreExtension">
            <summary>
            A collection of extension methods for <see cref="T:System.Data.Linq.Table`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.LinqToSqlSqlDataStoreExtension.Truncate``1(System.Data.Linq.Table{``0})">
            <summary>
            Calls the TRUNCATE SQL command on the <see cref="T:System.Data.Linq.Table`1"/>.
            </summary>
            <typeparam name="TEntity">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Entities.IEntity"/> to truncate all data of.</typeparam>
            <param name="table">The <see cref="T:System.Data.Linq.Table`1"/> to truncate all data of.</param>
        </member>
        <member name="T:Cqrs.DataStores.SqlDataStore`1">
            <summary>
            A <see cref="T:Cqrs.DataStores.IDataStore`1"/> using simplified Entity Framework.
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.ConfigurationManager">
            <summary />
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.#ctor(Cqrs.Configuration.IConfigurationManager,Chinchilla.Logging.ILogger)">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.DataStores.SqlDataStore`1"/> class
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.DbDataContext">
            <summary>
            Gets or sets the DataContext.
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.WriteableConnectionStrings">
            <summary>
            Gets or sets the list of writeable connection strings for data mirroring
            </summary>
        </member>
        <member name="F:Cqrs.DataStores.SqlDataStore`1._writeableConnections">
            <summary>
            Gets or sets the list of writeable DataContexts for data mirroring
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.WriteableConnections">
            <summary>
            Gets or sets the list of writeable DataContexts for data mirroring
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.Table">
            <summary>
            Gets or sets the readable Table
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.Logger">
            <summary>
            Gets or sets the Logger
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.CreateDbDataContext">
            <summary>
            Locate the connection settings and create a <see cref="T:System.Data.Entity.DbContext"/>.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.GetWriteableConnectionStrings">
            <summary>
            Locate the connection settings for persisting data.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.Expression">
            <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable"/>.
            </summary>
            <returns>
            The <see cref="T:System.Linq.Expressions.Expression"/> that is associated with this instance of <see cref="T:System.Linq.IQueryable"/>.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.ElementType">
            <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable"/> is executed.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.Provider">
            <summary>
            Gets the query provider that is associated with this data source.
            </summary>
            <returns>
            The <see cref="T:System.Linq.IQueryProvider"/> that is associated with this data source.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Add(`0)">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Remove(`0)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft) deleted by setting <see cref="P:Cqrs.Entities.Entity.IsDeleted"/> to true in the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Destroy(`0)">
            <summary>
            Remove the provided <paramref name="data"/> (normally by <see cref="P:Cqrs.Entities.IEntity.Rsn"/>) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.RemoveAll">
            <summary>
            Remove all contents (normally by use of a truncate operation) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Update(`0)">
            <summary>
            Update the provided <paramref name="data"/> in the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.SqlDbContext.#ctor(System.String)">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.DataStores.SqlDataStore`1.SqlDbContext"/> class using the given string as the name or connection string for the database to which a connection will be made. See the class remarks for how this is used to create a connection.
            </summary>
            <param name="nameOrConnectionString">Either the database name or a connection string.</param>
        </member>
        <member name="T:Cqrs.DataStores.SqlDataStoreExtension">
            <summary>
            A collection of extension methods for <see cref="T:System.Data.Entity.DbSet`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStoreExtension.Truncate``1(System.Data.Entity.DbSet{``0})">
            <summary>
            Calls the TRUNCATE SQL command on the <see cref="T:System.Data.Entity.DbSet`1"/>.
            </summary>
            <typeparam name="TEntity">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Entities.IEntity"/> to truncate all data of.</typeparam>
            <param name="table">The <see cref="T:System.Data.Entity.DbSet`1"/> to truncate all data of.</param>
        </member>
        <member name="T:Cqrs.Domain.AggregateRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> using an <see cref="T:Cqrs.Events.IEventStore`1"/>
            that also publishes events once saved.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.EventStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Events.IEventStore`1"/> used to store and retrieve events from.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.Publisher">
            <summary>
            Gets or sets the Publisher used to publish events on once saved into the <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.AggregateFactory">
            <summary>
            Gets or set the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.CorrelationIdHelper">
            <summary>
            Gets or set the <see cref="T:Chinchilla.Logging.ICorrelationIdHelper"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.ConfigurationManager">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IConfigurationManager"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.#ctor(Cqrs.Domain.Factories.IAggregateFactory,Cqrs.Events.IEventStore{`0},Cqrs.Events.IEventPublisher{`0},Chinchilla.Logging.ICorrelationIdHelper,Cqrs.Configuration.IConfigurationManager)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.AggregateRepository`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Save and persist the provided <paramref name="aggregate"/>, optionally providing the version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.PublishEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Publish the saved <paramref name="event"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.GetToVersion``1(System.Guid,System.Int32,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/> up to and including the provided <paramref name="version"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="version">Load events up-to and including from this version</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.GetToDate``1(System.Guid,System.DateTime,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/> up to and including the provided <paramref name="versionedDate"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.CreateAggregate``1(System.Guid)">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TAggregateRoot"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TAggregateRoot"/> to create.</param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.LoadAggregate``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TAggregateRoot"/> and then calls <see cref="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}},System.Boolean)"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TAggregateRoot"/> to create.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateToVersion``1(System.Guid,System.Int32,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TAggregateRoot"/> and then calls <see cref="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}},System.Boolean)"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TAggregateRoot"/> to create.</param>
            <param name="version">Load events up-to and including from this version</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateToDate``1(System.Guid,System.DateTime,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TAggregateRoot"/> and then calls <see cref="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}},System.Boolean)"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TAggregateRoot"/> to create.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}},System.Boolean)">
            <summary>
            If <paramref name="events"/> is null, loads the events from <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>, checks for duplicates and then
            rehydrates the <paramref name="aggregate"/> with the events.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <typeparamref name="TAggregateRoot"/> to rehydrate.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
            <param name="throwExceptionOnNoEvents">If true will throw an instance of <see cref="T:Cqrs.Domain.Exceptions.AggregateNotFoundException`2"/> if no aggregate events or provided or found in the <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>.</param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateHistoryToVersion``1(``0,System.Int32,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}},System.Boolean)">
            <summary>
            If <paramref name="events"/> is null, loads the events from <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>, checks for duplicates and then
            rehydrates the <paramref name="aggregate"/> with the events.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <typeparamref name="TAggregateRoot"/> to rehydrate.</param>
            <param name="version">Load events up-to and including from this version</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
            <param name="throwExceptionOnNoEvents">If true will throw an instance of <see cref="T:Cqrs.Domain.Exceptions.AggregateNotFoundException`2"/> if no aggregate events or provided or found in the <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>.</param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateHistoryToDate``1(``0,System.DateTime,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}},System.Boolean)">
            <summary>
            If <paramref name="events"/> is null, loads the events from <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>, checks for duplicates and then
            rehydrates the <paramref name="aggregate"/> with the events.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <typeparamref name="TAggregateRoot"/> to rehydrate.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
            <param name="throwExceptionOnNoEvents">If true will throw an instance of <see cref="T:Cqrs.Domain.Exceptions.AggregateNotFoundException`2"/> if no aggregate events or provided or found in the <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>.</param>
        </member>
        <member name="T:Cqrs.Domain.AggregateRoot`1">
            <summary>
            A larger unit of encapsulation than just a class. Every transaction is scoped to a single aggregate. The lifetimes of the components of an aggregate are bounded by the lifetime of the entire aggregate.
            
            Concretely, an aggregate will handle commands, apply events, and have a state model encapsulated within it that allows it to implement the required command validation, thus upholding the invariants (business rules) of the aggregate.
            </summary>
            <remarks>
            Why is the use of GUID as IDs a good practice?
            
            Because they are (reasonably) globally unique, and can be generated either by the server or by the client.
            </remarks>
        </member>
        <member name="P:Cqrs.Domain.AggregateRoot`1.Id">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRoot`1.Version">
            <summary>
            The current version of this <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.AggregateRoot`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.Initialise">
            <summary>
            Initialise any properties
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.GetUncommittedChanges">
            <summary>
            Get all applied changes that haven't yet been committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.MarkChangesAsCommitted">
            <summary>
            Mark all applied changes as committed, increment <see cref="P:Cqrs.Domain.AggregateRoot`1.Version"/> and flush the <see cref="P:Cqrs.Domain.AggregateRoot`1.Changes">internal collection of changes</see>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.LoadFromHistory(System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}})">
            <summary>
            Apply all the <see cref="T:Cqrs.Events.IEvent`1">events</see> in <paramref name="history"/>
            using event replay to this instance.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.ApplyChange(Cqrs.Events.IEvent{`0})">
            <summary>
            Call the "Apply" method with a signature matching the provided <paramref name="event"/> without using event replay to this instance.
            </summary>
            <remarks>
            This means a method named "Apply", with return type void and one parameter must exist to be applied.
            If no method exists, nothing is applied
            The parameter type must match exactly the <see cref="T:System.Type"/> of the provided <paramref name="event"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.ApplyChanges(System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}})">
            <summary>
            Call the "Apply" method with a signature matching each <see cref="T:Cqrs.Events.IEvent`1"/> in the provided <paramref name="events"/> without using event replay to this instance.
            </summary>
            <remarks>
            This means a method named "Apply", with return type void and one parameter must exist to be applied.
            If no method exists, nothing is applied
            The parameter type must match exactly the <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> in the provided <paramref name="events"/>.
            </remarks>
        </member>
        <member name="T:Cqrs.Domain.DtoAggregateRoot`2">
            <summary>
            An <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> for operating on <see cref="T:Cqrs.Domain.IDto"/> instances.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TDto">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IDto"/>.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.DtoAggregateRoot`2.#ctor(System.Guid,`1,`1)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.DtoAggregateRoot`2"/>
            and instantly apply the change as n <see cref="T:Cqrs.Events.DtoAggregateEvent`2"/>
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IDto"/>.</param>
            <param name="original">The original copy of the <see cref="T:Cqrs.Domain.IDto"/>. May be null for a <see cref="F:Cqrs.Events.DtoAggregateEventType.Created"/> operation.</param>
            <param name="new">The new copy of the <see cref="T:Cqrs.Domain.IDto"/>. May be null for a <see cref="F:Cqrs.Events.DtoAggregateEventType.Deleted"/> operation.</param>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.AggregateNotFoundException`2">
            <summary>
            The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> requested was not found.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.AggregateNotFoundException`2.#ctor(System.Guid)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.AggregateNotFoundException`2"/> with the provided identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.AggregateNotFoundException`2.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.AggregateNotFoundException`2.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException">
            <summary>
            The <see cref="T:Cqrs.Events.IEvent`1"/> had not <see cref="P:Cqrs.Events.IEvent`1.Id"/> set.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException.#ctor(System.Type,System.Type)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException"/> with the <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> and <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            The <paramref name="eventType"/> that was trying to be saved on an <paramref name="aggregateType"/>.
            </summary>
            <param name="aggregateType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that the <see cref="T:Cqrs.Events.IEvent`1"/> was trying to be saved on.</param>
            <param name="eventType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> that was trying to be saved.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that the <see cref="T:Cqrs.Events.IEvent`1"/> was trying to be saved on.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException.EventType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> that was trying to be saved.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.ConcurrencyException">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> was processed out of order or an expected <see cref="T:Cqrs.Events.IEvent`1"/> was not found.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.ConcurrencyException.#ctor(System.Guid)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.ConcurrencyException"/> with the provided identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had a concurrency issue.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.ConcurrencyException.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had a concurrency issue.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.DuplicateCreateCommandException">
            <summary>
            The operation resulted in a duplicate.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.#ctor(System.String,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateCreateCommandException"/> with a specified <paramref name="message">error message</paramref> and a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.#ctor(System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateCreateCommandException"/> with a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.#ctor(System.Type,System.Guid,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateCreateCommandException"/> with 
            the <paramref name="commandType"/> and <paramref name="commandId"/> that was issued as well as
            a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="commandType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Commands.ICommand`1"/> that was issued.</param>
            <param name="commandId">The <see cref="P:Cqrs.Commands.ICommand`1.Id"/> of the <see cref="T:Cqrs.Commands.ICommand`1"/> that was issued.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.CommandType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Commands.ICommand`1"/> that was issued.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.CommandId">
            <summary>
            The <see cref="P:Cqrs.Commands.ICommand`1.Id"/> of the <see cref="T:Cqrs.Commands.ICommand`1"/> that was issued.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.DuplicateEventException`2">
            <summary>
            The <see cref="T:Cqrs.Events.IEventStore`1"/> gave more than one <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateEventException`2.#ctor(System.Guid,System.Int32)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateEventException`2"/> with the provided identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>.
            and the <paramref name="version"/> that had more than one <see cref="T:Cqrs.Events.IEvent`1"/> provided.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had <see cref="T:Cqrs.Events.IEvent`1">events</see>.</param>
            <param name="version">The version number of the duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see></param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateEventException`2.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>..
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateEventException`2.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>..
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2">
            <summary>
            The <see cref="T:Cqrs.Events.IEventStore`1"/> gave more than one event.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2.#ctor(System.Guid,System.Int32)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2"/> with the provided identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>.
            and the <paramref name="version"/> that had more than one <see cref="T:Cqrs.Events.IEvent`1"/> provided.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that had <see cref="T:Cqrs.Events.IEvent`1">events</see>.</param>
            <param name="version">The version number of the duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see></param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>..
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2.SagaType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>..
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.EntityNotFoundException`1">
            <summary>
            The <see cref="T:Cqrs.Entities.IEntity"/> requested was not found.
            </summary>
            <typeparam name="TEntity">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.EntityNotFoundException`1.#ctor(System.Guid)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.EntityNotFoundException`1"/> with the provided identifier of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EntityNotFoundException`1.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EntityNotFoundException`1.EntityType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.EventsOutOfOrderException">
            <summary>
            The <see cref="T:Cqrs.Events.IEventStore`1"/> gave <see cref="T:Cqrs.Events.IEvent`1">events</see> out of order
            or an expected <see cref="T:Cqrs.Events.IEvent`1"/> with a specific version number wasn't provided.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.EventsOutOfOrderException.#ctor(System.Guid,System.Type,System.Int32,System.Int32)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.EventsOutOfOrderException"/> with the provided identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had out of order <see cref="T:Cqrs.Events.IEvent`1" />.
            and the <paramref name="currentVersion"/> the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> was at and the <paramref name="providedEventVersion">the event version that was provided</paramref>.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had <see cref="T:Cqrs.Events.IEvent`1">events</see>.</param>
            <param name="aggregateType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that the <see cref="T:Cqrs.Events.IEvent`1"/> was trying to be saved on.</param>
            <param name="currentVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> was at when it received an out of order <see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="providedEventVersion">The version number the <see cref="T:Cqrs.Events.IEvent`1"/> that was provided, that was out of order.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EventsOutOfOrderException.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had out of order <see cref="T:Cqrs.Events.IEvent`1" />.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EventsOutOfOrderException.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had out of order <see cref="T:Cqrs.Events.IEvent`1" />.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EventsOutOfOrderException.CurrentVersion">
            <summary>
            The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> was at when it received an out of order <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EventsOutOfOrderException.ProvidedEventVersion">
            <summary>
            The version number the <see cref="T:Cqrs.Events.IEvent`1"/> that was provided, that was out of order.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException">
            <summary>
            A parameterless constructor is missing.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.#ctor(System.Type)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException"/> with the <see cref="P:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.Type"/> of the object that needs to have a parameterless constructor.
            </summary>
            <param name="type">The <see cref="P:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.Type"/> of the object that needs to have a parameterless constructor.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.Type">
            <summary>
            The <see cref="P:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.Type"/> of the object that needs to have a parameterless constructor.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.SagaNotFoundException`2">
            <summary>
            The <see cref="T:Cqrs.Domain.ISaga`1"/> requested was not found.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.SagaNotFoundException`2.#ctor(System.Guid)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.SagaNotFoundException`2"/> with the provided identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.SagaNotFoundException`2.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.SagaNotFoundException`2.SagaType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Factories.AggregateFactory">
            <summary>
            A factory for creating instances of aggregates.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Factories.AggregateFactory.DependencyResolver">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IDependencyResolver"/> used.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Factories.AggregateFactory.Logger">
            <summary>
            Gets or sets the <see cref="T:Chinchilla.Logging.ILogger"/> used.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Factories.AggregateFactory.#ctor(Cqrs.Configuration.IDependencyResolver,Chinchilla.Logging.ILogger)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.Factories.AggregateFactory"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Factories.AggregateFactory.Create``1(System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Creates instance of <typeparamref name="TAggregate"/>.
            </summary>
            <typeparam name="TAggregate">The <see cref="T:System.Type"/> of the aggregate to create.</typeparam>
            <param name="rsn">The identifier of the aggregate to create an instance of if an existing aggregate.</param>
            <param name="tryDependencyResolutionFirst">Indicates the use of <see cref="T:Cqrs.Configuration.IDependencyResolver"/> should be tried first.</param>
        </member>
        <member name="M:Cqrs.Domain.Factories.AggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Creates instance of type <paramref name="aggregateType"/>
            </summary>
            <param name="aggregateType">The <see cref="T:System.Type"/> of the aggregate to create.</param>
            <param name="rsn">The identifier of the aggregate to create an instance of if an existing aggregate.</param>
            <param name="tryDependencyResolutionFirst">Indicates the use of <see cref="T:Cqrs.Configuration.IDependencyResolver"/> should be tried first.</param>
        </member>
        <member name="T:Cqrs.Domain.Factories.IAggregateFactory">
            <summary>
            A factory for creating instances of aggregates.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Factories.IAggregateFactory.Create``1(System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Creates instance of <typeparamref name="TAggregate"/>.
            </summary>
            <typeparam name="TAggregate">The <see cref="T:System.Type"/> of the aggregate to create.</typeparam>
            <param name="rsn">The identifier of the aggregate to create an instance of if an existing aggregate.</param>
            <param name="tryDependencyResolutionFirst">Indicates the use of <see cref="T:Cqrs.Configuration.IDependencyResolver"/> should be tried first.</param>
        </member>
        <member name="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Creates instance of type <paramref name="aggregateType"/>
            </summary>
            <param name="aggregateType">The <see cref="T:System.Type"/> of the aggregate to create.</param>
            <param name="rsn">The identifier of the aggregate to create an instance of if an existing aggregate.</param>
            <param name="tryDependencyResolutionFirst">Indicates the use of <see cref="T:Cqrs.Configuration.IDependencyResolver"/> should be tried first.</param>
        </member>
        <member name="T:Cqrs.Domain.IAggregateRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Save and persist the provided <paramref name="aggregate"/>, optionally providing the version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRepository`1.GetToVersion``1(System.Guid,System.Int32,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/> up to and including the provided <paramref name="version"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="version">Load events up-to and including from this version</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRepository`1.GetToDate``1(System.Guid,System.DateTime,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/> up to and including the provided <paramref name="versionedDate"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="T:Cqrs.Domain.IAggregateRoot`1">
            <summary>
            An <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is a larger unit of encapsulation than just a class. Every transaction is scoped to a single aggregate. The lifetimes of the components of an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are bounded by the lifetime of the entire <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            
            <para />Concretely, an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> will handle <see cref="T:Cqrs.Commands.ICommand`1"/>s, apply <see cref="T:Cqrs.Events.IEvent`1"/>s, and have a state model encapsulated within it that allows it to implement the required command validation, thus upholding the invariants (business rules) of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
            <remarks>
            I know <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are transaction boundaries, but I really need to transactionally update two <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> in the same transaction. What should I do?
            
            <para />You should re-think the following:
            <para />* Your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> boundaries.
            <para />* The responsibilities of each <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            <para />* What you can get away with doing in a read side or in a saga.
            <para />* The actual non-functional requirements of your domain.
            <para />
            <para />If you write a solution where two or more <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are transactionally coupled, you have not understood <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            <para />
            <para />
            <para />Why is the use of <see cref="T:System.Guid"/> as identifiers a good practice?
            <para />
            <para />Because they are (reasonably) globally unique, and can be generated either by the server or by the client.
            <para />
            <para />
            <para />What is an Rsn and what is an Id?
            <para />
            <para />Because few systems are truely green field and there is usually some existing system to operate with our framework identifies
            <para />Id properties as <see cref="T:System.Int32"/> typed properties from an external system
            <para />and Rsn properties as <see cref="T:System.Guid"/> typed properties for internal use.
            <para />
            <para />An example might be
            <para />{
            <para />	Guid Rsn
            <para />	string Name
            <para />	Guid CategoryRsn
            <para />	int CategoryId
            <para />}
            <para />
            <para />Here the category can be referenced within the CQRS framework by it's Rsn <see cref="T:System.Guid"/> typed identifier, but still has a reference to the external systems <see cref="T:System.Int32"/> typed identifier value.
            <para />
            <para />
            <para />How can I get the Rsn for newly created <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para />
            <para />It's an important insight that the client can generate its own Rsns.
            <para />
            <para />If the client generates a <see cref="T:System.Guid"/> and places it in the create-the-aggregate <see cref="T:Cqrs.Commands.ICommand`1"/>, this is a non-issue. Otherwise, you have to listen to the the appropriate the-aggregate-was-created <see cref="T:Cqrs.Events.IEvent`1"/>, where the Rsn will appear be populated.
            <para />
            <para />
            <para />Should I allow references between <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para />
            <para />In the sense of an actual "memory reference", absolutely not.
            <para />
            <para />On the write side, an actual memory reference from one <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to another is forbidden and wrong, since <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> by definition are not allowed to reach outside of themselves. (Allowing this would mean an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is no longer a transaction boundary, meaning we can no longer sanely reason about its ability to uphold its invariants; it would also preclude sharding of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.)
            <para />
            <para />Referring to another <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> using an identifier is fine. It is useless on the write side (since the identifier must be treated as an opaque value, since <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> can not reach outside of themselves). Read sides may freely use such information, however, to do interesting correlations.
            <para />
            <para />
            <para />How can I validate a <see cref="T:Cqrs.Commands.ICommand`1"/> across a group of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para />
            <para />This is a common reaction to not being able to query across <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> anymore. There are several answers:
            <para />
            <para />* Do client-side validation.
            <para />* Use a read side.
            <para />* Use a saga.
            <para />* If those are all completely impractical, then it's time to consider if you got your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> boundaries correct.
            <para />
            <para />
            <para />How can I guarantee referential integrity across <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para />
            <para />You're still thinking in terms of foreign relations, not <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>. See last question. Also, remember that just because something would be in two tables in a relational design does not in any way suggest it should be two <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>. Designing an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is different.
            <para />
            <para />
            <para />How can I make sure a newly created user has a unique user name?
            <para />
            <para />This is a commonly occurring question since we're explicitly not performing cross-aggregate operations on the write side. We do, however, have a number of options:
            <para />
            <para />* Create a read-side of already allocated user names. Make the client query the read-side interactively as the user types in a name.
            <para />* Create a reactive saga to flag down and inactivate accounts that were nevertheless created with a duplicate user name. (Whether by extreme coincidence or maliciously or because of a faulty client.)
            <para />
            <para />
            <para />How can I verify that a customer identifier really exists when I place an order?
            <para />
            <para />Assuming customer and order are <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> here, it's clear that the order <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> cannot really validate this, since that would mean reaching out of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            <para />
            <para />Checking up on it after the fact, in a saga or just in a read side that records "broken" orders, is one option. After all, the most important thing about an order is actually recording it, and presumably any interesting data about the recipient of the order is being copied into the order <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> (referring to the customer to find the address is bad design; the order was always made to be deliverd to a particular address, whether or not that customer changes their address in the future).
            <para />
            <para />Being able to use what data was recorded in this broken order means you've got a chance to rescue it and rectify the situation - which makes a good bit more business sense rather than dropping the order on the floor because a foreign key constraint was violated!
            <para />
            <para />
            <para />How can I update a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> with a single <see cref="T:Cqrs.Commands.ICommand`1"/>?
            <para />
            <para />A single <see cref="T:Cqrs.Commands.ICommand`1"/> can't act on a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>. It just can't.
            <para />
            <para />First off, ask yourself whether you really need to update several <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> using just one <see cref="T:Cqrs.Commands.ICommand`1"/>. What in the situation makes this a requirement?
            <para />
            <para />However, here's what you could do. Allow a new kind of "bulk command", conceptually containing the command you want to issue, and a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> (specified either explicitly or implicitly) that you want to issue it on. The write side isn't powerful enough to make the bulk action, but it's able to create a corresponding "bulk event". A saga captures the event, and issues the <see cref="T:Cqrs.Commands.ICommand`1"/> on each of the specified <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>s. The saga can do rollback or send an email, as appropriate, if some of the <see cref="T:Cqrs.Commands.ICommand`1"/> fail.
            <para />
            <para />There are some advantages to this approach: we store the intent of the bulk action in the event store. The saga automates rollback or equivalent.
            <para />
            <para />Still, having to resort to this solution is a strong indication that your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> boundaries are not drawn correctly. You might want to consider changing your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> boundaries rather than building a saga for this.
            <para />
            <para />
            <para />What is sharding?
            <para />
            <para />A way to distribute large amounts of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> on several write-side nodes. We can shard <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> easily because they are completely self-reliant.
            <para />
            <para />We can shard <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> easily because they don't have any external references.
            <para />
            <para />
            <para />Can an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> send an <see cref="T:Cqrs.Events.IEvent`1"/> to another <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para />
            <para />No.
            <para />
            <para />The factoring of your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> and <see cref="T:Cqrs.Commands.ICommandHandler`2"/> will typically already make this idea impossible to express in code. But there's a deeper philosophical reason: go back and re-read the first sentence in the answer to "What is an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?". If you manage to circumvent the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> and just push <see cref="T:Cqrs.Events.IEvent`1"/> into another <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> somehow, you will have taken away that <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>'s chance to participate in validation of changes. That's ultimately why we only allow <see cref="T:Cqrs.Events.IEvent`1"/> to be created as a result of <see cref="T:Cqrs.Commands.ICommand`1"/>s validated by a <see cref="T:Cqrs.Commands.ICommandHandler`2"/> on an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            <para />
            <para />
            <para />Can I call a read side from my <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para />
            <para />No.
            <para />
            <para />
            <para />How do I send e-mail in a CQRS system?
            <para />
            <para />In an <see cref="T:Cqrs.Events.IEventHandler`2"/> outside of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>. Do not do it in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>, as if the <see cref="T:Cqrs.Events.IEvent`1"/> artefacts are not persisted due to losing a race with another <see cref="T:Cqrs.Commands.ICommand`1"/> then the email will have been sent on a false premise.
            <para />********************************************
            <para />Also see http://cqrs.nu/Faq/aggregates.
            </remarks>
        </member>
        <member name="P:Cqrs.Domain.IAggregateRoot`1.Id">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.IAggregateRoot`1.Version">
            <summary>
            The current version of this <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRoot`1.GetUncommittedChanges">
            <summary>
            Get all applied changes that haven't yet been committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRoot`1.MarkChangesAsCommitted">
            <summary>
            Mark all applied changes as committed, increment <see cref="P:Cqrs.Domain.IAggregateRoot`1.Version"/> and flush the internal collection of changes.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRoot`1.LoadFromHistory(System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}})">
            <summary>
            Apply all the <see cref="T:Cqrs.Events.IEvent`1">events</see> in <paramref name="history"/>
            using event replay to this instance.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.IDto">
            <summary>
            A basic data transfer object suitable for CRUD operations.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.IDto.Id">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.IDto"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.ISaga`1">
            <summary>
            An independent component that reacts to domain <see cref="T:Cqrs.Events.IEvent`1"/> in a cross-<see cref="T:Cqrs.Domain.IAggregateRoot`1"/>, eventually consistent manner. Time can also be a trigger. A <see cref="T:Cqrs.Domain.Saga`1"/> can sometimes be purely reactive, and sometimes represent workflows.
            
            From an implementation perspective, a <see cref="T:Cqrs.Domain.Saga`1"/> is a state machine that is driven forward by incoming <see cref="T:Cqrs.Events.IEvent`1"/> (which may come from many <see cref="T:Cqrs.Domain.AggregateRoot`1"/> or other <see cref="T:Cqrs.Domain.Saga`1"/>). Some states will have side effects, such as sending <see cref="T:Cqrs.Commands.ICommand`1"/>, talking to external web services, or sending emails.
            </summary>
            <remarks>
            Isn't a <see cref="T:Cqrs.Domain.Saga`1"/> just leaked domain logic?
            No.
            A <see cref="T:Cqrs.Domain.Saga`1"/> can doing things that no individual <see cref="T:Cqrs.Domain.AggregateRoot`1"/> can sensibly do. Thus, it's not a logic leak since the logic didn't belong in an <see cref="T:Cqrs.Domain.AggregateRoot`1"/> anyway. Furthermore, we're not breaking encapsulation in any way, since <see cref="T:Cqrs.Domain.Saga`1"/> operate with <see cref="T:Cqrs.Commands.ICommand`1"/> and <see cref="T:Cqrs.Events.IEvent`1"/>, which are part of the public API.
            
            How can I make my <see cref="T:Cqrs.Domain.Saga`1"/> react to an <see cref="T:Cqrs.Events.IEvent`1"/> that did not happen?
            The <see cref="T:Cqrs.Domain.Saga`1"/>, besides reacting to domain <see cref="T:Cqrs.Events.IEvent`1"/>, can be "woken up" by recurrent internal alarms. Implementing such alarms is easy. See cron in Unix, or triggered WebJobs in Azure for examples.
            
            How does the <see cref="T:Cqrs.Domain.Saga`1"/> interact with the write side?
            By sending an <see cref="T:Cqrs.Commands.ICommand`1"/> to it.
            </remarks>
        </member>
        <member name="P:Cqrs.Domain.ISaga`1.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.ISaga`1.Version">
            <summary>
            The current version of this <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISaga`1.GetUncommittedChanges">
            <summary>
            Get all applied changes that haven't yet been committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISaga`1.MarkChangesAsCommitted">
            <summary>
            Mark all applied changes as committed, increment <see cref="P:Cqrs.Domain.ISaga`1.Version"/> and flush the internal collection of changes.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISaga`1.LoadFromHistory(System.Collections.Generic.IEnumerable{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Apply all the <see cref="T:Cqrs.Events.IEvent`1">events</see> in <paramref name="history"/>
            using event replay to this instance.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISaga`1.GetUnpublishedCommands">
            <summary>
            Get all pending commands that haven't yet been published yet.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISaga`1.MarkCommandsAsPublished">
            <summary>
            Mark all published commands as published and flush the internal collection of commands.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.ISagaRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.ISagaRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Save and persist the provided <paramref name="saga"/>, optionally providing the version number the <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be at.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="saga">The <see cref="T:Cqrs.Domain.ISaga`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Domain.ISagaRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.ISaga`1"/> of type <typeparamref name="TSaga"/>.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="sagaId">The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.ISaga`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="T:Cqrs.Domain.ISagaUnitOfWork`1">
            <summary>
            This is a Unit of Work for sagas
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISagaUnitOfWork`1.Add``1(``0)">
            <summary>
            Add an item into the <see cref="T:Cqrs.Domain.ISagaUnitOfWork`1"/> ready to be committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISagaUnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32})">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.ISagaUnitOfWork`1"/> if it has already been loaded.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISagaUnitOfWork`1.Commit">
            <summary>
            Commit any changed <see cref="T:Cqrs.Domain.Saga`1"/> added to this <see cref="T:Cqrs.Domain.ISagaUnitOfWork`1"/> via <see cref="M:Cqrs.Domain.ISagaUnitOfWork`1.Add``1(``0)"/>
            </summary>
        </member>
        <member name="T:Cqrs.Domain.ISnapshotAggregateRepository`1">
            <summary>
            Provides basic snapshot repository methods for operations with instances of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Domain.IUnitOfWork`1">
            <summary>
            Provides a basic container to control when <see cref="T:Cqrs.Events.IEvent`1">events</see> are store in an <see cref="T:Cqrs.Events.IEventStore`1"/> and then published on an <see cref="T:Cqrs.Events.IEventPublisher`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IUnitOfWork`1.Add``1(``0,System.Boolean)">
            <summary>
            Add an item into the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> ready to be committed.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.IUnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> if it has already been loaded.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.IUnitOfWork`1.GetToVersion``1(System.Guid,System.Int32)">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> up to and including the provided <paramref name="version"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="id">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="version">Load events up-to and including from this version</param>
        </member>
        <member name="M:Cqrs.Domain.IUnitOfWork`1.GetToDate``1(System.Guid,System.DateTime)">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> up to and including the provided <paramref name="versionedDate"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="id">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
        </member>
        <member name="M:Cqrs.Domain.IUnitOfWork`1.Commit">
            <summary>
            Commit any changed <see cref="T:Cqrs.Domain.AggregateRoot`1"/> added to this <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> via <see cref="M:Cqrs.Domain.IUnitOfWork`1.Add``1(``0,System.Boolean)"/>
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Saga`1">
            <summary>
            An independent component that reacts to domain <see cref="T:Cqrs.Events.IEvent`1"/> in a cross-<see cref="T:Cqrs.Domain.IAggregateRoot`1"/>, eventually consistent manner. Time can also be a trigger. A <see cref="T:Cqrs.Domain.Saga`1"/> can sometimes be purely reactive, and sometimes represent workflows.
            
            From an implementation perspective, a <see cref="T:Cqrs.Domain.Saga`1"/> is a state machine that is driven forward by incoming <see cref="T:Cqrs.Events.IEvent`1"/> (which may come from many <see cref="T:Cqrs.Domain.AggregateRoot`1"/> or other <see cref="T:Cqrs.Domain.Saga`1"/>). Some states will have side effects, such as sending <see cref="T:Cqrs.Commands.ICommand`1"/>, talking to external web services, or sending emails.
            </summary>
            <remarks>
            Isn't a <see cref="T:Cqrs.Domain.Saga`1"/> just leaked domain logic?
            No.
            A <see cref="T:Cqrs.Domain.Saga`1"/> can doing things that no individual <see cref="T:Cqrs.Domain.AggregateRoot`1"/> can sensibly do. Thus, it's not a logic leak since the logic didn't belong in an <see cref="T:Cqrs.Domain.AggregateRoot`1"/> anyway. Furthermore, we're not breaking encapsulation in any way, since <see cref="T:Cqrs.Domain.Saga`1"/> operate with <see cref="T:Cqrs.Commands.ICommand`1"/> and <see cref="T:Cqrs.Events.IEvent`1"/>, which are part of the public API.
            
            How can I make my <see cref="T:Cqrs.Domain.Saga`1"/> react to an <see cref="T:Cqrs.Events.IEvent`1"/> that did not happen?
            The <see cref="T:Cqrs.Domain.Saga`1"/>, besides reacting to domain <see cref="T:Cqrs.Events.IEvent`1"/>, can be "woken up" by recurrent internal alarms. Implementing such alarms is easy. See cron in Unix, or triggered WebJobs in Azure for examples.
            
            How does the <see cref="T:Cqrs.Domain.Saga`1"/> interact with the write side?
            By sending an <see cref="T:Cqrs.Commands.ICommand`1"/> to it.
            </remarks>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.Rsn">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.Id">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.Version">
            <summary>
            The current version of this <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.CommandPublisher">
            <summary>
            Gets or set the <see cref="T:Cqrs.Commands.ICommandPublisher`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.DependencyResolver">
            <summary>
            Gets or set the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.Logger">
            <summary>
            Gets or set the <see cref="T:Chinchilla.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.#ctor">
            <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.Initialise">
            <summary>
            Initialise any properties
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.#ctor(Cqrs.Configuration.IDependencyResolver,Chinchilla.Logging.ILogger)">
            <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.#ctor(Cqrs.Configuration.IDependencyResolver,Chinchilla.Logging.ILogger,System.Guid)">
            <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.GetUncommittedChanges">
            <summary>
            Get all applied changes that haven't yet been committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.MarkChangesAsCommitted">
            <summary>
            Mark all applied changes as committed, increment <see cref="P:Cqrs.Domain.Saga`1.Version"/> and flush the <see cref="P:Cqrs.Domain.Saga`1.Changes">internal collection of changes</see>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.LoadFromHistory(System.Collections.Generic.IEnumerable{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Apply all the <see cref="T:Cqrs.Events.IEvent`1">events</see> in <paramref name="history"/>
            using event replay to this instance.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.GetUnpublishedCommands">
            <summary>
            Get all pending commands that haven't yet been published yet.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.QueueCommand(Cqrs.Commands.ICommand{`0})">
            <summary>
            Queue the provided <paramref name="command"/> for publishing.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.MarkCommandsAsPublished">
            <summary>
            Mark all published commands as published and flush the internal collection of commands.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.ApplyChange(Cqrs.Events.ISagaEvent{`0})">
            <summary>
            Call the "Apply" method with a signature matching the provided <paramref name="event"/> without using event replay to this instance.
            </summary>
            <remarks>
            This means a method named "Apply", with return type void and one parameter must exist to be applied.
            If no method exists, nothing is applied
            The parameter type must match exactly the <see cref="T:System.Type"/> of the provided <paramref name="event"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.ApplyChange(Cqrs.Events.IEvent{`0})">
            <summary>
            Calls the "SetId" method dynamically if the method exists, then calls <see cref="M:Cqrs.Domain.Saga`1.ApplyChange(Cqrs.Events.ISagaEvent{`0})"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.SetId(Cqrs.Events.ISagaEvent{`0})">
            <summary>
            Sets the <see cref="P:Cqrs.Events.IEvent`1.Id"/> from <see cref="P:Cqrs.Events.ISagaEvent`1.Event"/> back onto <paramref name="sagaEvent"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.ApplyChanges(System.Collections.Generic.IEnumerable{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Call the "Apply" method with a signature matching each <see cref="T:Cqrs.Events.ISagaEvent`1"/> in the provided <paramref name="events"/> without using event replay to this instance.
            </summary>
            <remarks>
            This means a method named "Apply", with return type void and one parameter must exist to be applied.
            If no method exists, nothing is applied
            The parameter type must match exactly the <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> in the provided <paramref name="events"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.ApplyChanges(System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}})">
            <summary>
            Calls the "SetId" method dynamically if the method exists on the first <see cref="T:Cqrs.Events.IEvent`1"/> in the provided <paramref name="events"/>,
            then calls <see cref="M:Cqrs.Domain.Saga`1.ApplyChanges(System.Collections.Generic.IEnumerable{Cqrs.Events.ISagaEvent{`0}})"/>
            </summary>
        </member>
        <member name="T:Cqrs.Domain.SagaEventHandler`2">
            <summary>
            A process manager that you can implement <see cref="T:Cqrs.Events.IEventHandler"/> instances on top of.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
        </member>
        <member name="P:Cqrs.Domain.SagaEventHandler`2.SagaUnitOfWork">
            <summary>
            Gets or set the <see cref="T:Cqrs.Domain.ISagaUnitOfWork`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaEventHandler`2.DependencyResolver">
            <summary>
            Gets or set the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaEventHandler`2.Logger">
            <summary>
            Gets or set the <see cref="T:Chinchilla.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaEventHandler`2.#ctor(Cqrs.Configuration.IDependencyResolver,Chinchilla.Logging.ILogger)">
            <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaEventHandler`2.#ctor(Cqrs.Configuration.IDependencyResolver,Chinchilla.Logging.ILogger,Cqrs.Domain.ISagaUnitOfWork{`0})">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.SagaEventHandler`2"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaEventHandler`2.GetSaga(System.Guid)">
            <summary>
            Gets the <typeparamref name="TSaga"/> from the <see cref="P:Cqrs.Domain.SagaEventHandler`2.SagaUnitOfWork"/>.
            </summary>
            <param name="id">The identifier of the <typeparamref name="TSaga"/> to get.</param>
        </member>
        <member name="T:Cqrs.Domain.SagaRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.EventStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Events.IEventStore`1"/> used to store and retrieve events from.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.Publisher">
            <summary>
            Gets or sets the Publisher used to publish events on once saved into the <see cref="P:Cqrs.Domain.SagaRepository`1.EventStore"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.CommandPublisher">
            <summary>
            Gets or sets the Publisher used to publish an <see cref="T:Cqrs.Commands.ICommand`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.SagaFactory">
            <summary>
            Gets or set the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.CorrelationIdHelper">
            <summary>
            Gets or set the <see cref="T:Chinchilla.Logging.ICorrelationIdHelper"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.#ctor(Cqrs.Domain.Factories.IAggregateFactory,Cqrs.Events.IEventStore{`0},Cqrs.Events.IEventPublisher{`0},Cqrs.Commands.ICommandPublisher{`0},Chinchilla.Logging.ICorrelationIdHelper)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.SagaRepository`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Save and persist the provided <paramref name="saga"/>, optionally providing the version number the <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be at.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="saga">The <see cref="T:Cqrs.Domain.ISaga`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.PublishEvent(Cqrs.Events.ISagaEvent{`0})">
            <summary>
            Publish the saved <paramref name="event"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.PublishCommand(System.Collections.Generic.IEnumerable{Cqrs.Commands.ICommand{`0}})">
            <summary>
            Publish the <paramref name="commands"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.ISaga`1"/> of type <typeparamref name="TSaga"/>.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="sagaId">The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.ISaga`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.CreateSaga``1(System.Guid)">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TSaga"/>.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TSaga"/> to create.</param>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.LoadSaga``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TSaga"/> and then calls <see cref="M:Cqrs.Domain.SagaRepository`1.LoadSagaHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}},System.Boolean)"/>.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TSaga"/> to create.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.ISaga`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.LoadSagaHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}},System.Boolean)">
            <summary>
            If <paramref name="events"/> is null, loads the events from <see cref="P:Cqrs.Domain.SagaRepository`1.EventStore"/>, checks for duplicates and then
            rehydrates the <paramref name="saga"/> with the events.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="saga">The <typeparamref name="TSaga"/> to rehydrate.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.ISaga`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
            <param name="throwExceptionOnNoEvents">If true will throw an instance of <see cref="T:Cqrs.Domain.Exceptions.SagaNotFoundException`2"/> if no aggregate events or provided or found in the <see cref="P:Cqrs.Domain.SagaRepository`1.EventStore"/>.</param>
        </member>
        <member name="T:Cqrs.Domain.SagaUnitOfWork`1">
            <summary>
            Provides a basic container to control when <see cref="T:Cqrs.Events.IEvent`1">events</see> are store in an <see cref="T:Cqrs.Events.IEventStore`1"/> and then published on an <see cref="T:Cqrs.Events.IEventPublisher`1"/>.
            </summary>
            <remarks>
            This shouldn't normally be used as a singleton.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.SagaUnitOfWork`1.#ctor(Cqrs.Domain.ISagaRepository{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.SagaUnitOfWork`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaUnitOfWork`1.Add``1(``0)">
            <summary>
            Add an item into the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> ready to be committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaUnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32})">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> if it has already been loaded or get it from the <see cref="T:Cqrs.Domain.ISagaRepository`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaUnitOfWork`1.Commit">
            <summary>
            Commit any changed <see cref="T:Cqrs.Domain.Saga`1"/> added to this <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> via <see cref="M:Cqrs.Domain.SagaUnitOfWork`1.Add``1(``0)"/>
            into the <see cref="T:Cqrs.Domain.ISagaRepository`1"/>
            </summary>
        </member>
        <member name="T:Cqrs.Domain.UnitOfWork`1">
            <summary>
            Provides a basic container to control when <see cref="T:Cqrs.Events.IEvent`1">events</see> are store in an <see cref="T:Cqrs.Events.IEventStore`1"/> and then published on an <see cref="T:Cqrs.Events.IEventPublisher`1"/>.
            </summary>
            <remarks>
            This shouldn't normally be used as a singleton.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.#ctor(Cqrs.Domain.ISnapshotAggregateRepository{`0},Cqrs.Domain.IAggregateRepository{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.UnitOfWork`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.#ctor(Cqrs.Domain.IAggregateRepository{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.UnitOfWork`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.Add``1(``0,System.Boolean)">
            <summary>
            Add an item into the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> ready to be committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> if it has already been loaded or get it from the <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.GetToVersion``1(System.Guid,System.Int32)">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> up to and including the provided <paramref name="version"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="id">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="version">Load events up-to and including from this version</param>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.GetToDate``1(System.Guid,System.DateTime)">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> up to and including the provided <paramref name="versionedDate"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="id">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.Commit">
            <summary>
            Commit any changed <see cref="T:Cqrs.Domain.AggregateRoot`1"/> added to this <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> via <see cref="M:Cqrs.Domain.UnitOfWork`1.Add``1(``0,System.Boolean)"/>
            into the <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>
            </summary>
        </member>
        <member name="T:Cqrs.Entities.DateRange">
            <summary>
            A <see cref="T:Cqrs.Entities.Range`1"/> object for collecting a <see cref="T:System.DateTime"/> lower and upper limit.
            </summary>
        </member>
        <member name="M:Cqrs.Entities.DateRange.#ctor">
            <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.DateRange"/> class.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.DecimalRange">
            <summary>
            A <see cref="T:Cqrs.Entities.Range`1"/> object for collecting a <see cref="T:System.Decimal"/> lower and upper limit.
            </summary>
        </member>
        <member name="M:Cqrs.Entities.DecimalRange.#ctor">
            <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.DecimalRange"/> class.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.Entity">
            <summary>
            A projection/entity.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Entity.Rsn">
            <summary>
            The identifier of the <see cref="T:Cqrs.Entities.IEntity"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Entity.SortingOrder">
            <summary>
            The order of this <see cref="T:Cqrs.Entities.IEntity"/> to sort by, by default.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Entity.IsDeleted">
            <summary>
            Indicates if this <see cref="T:Cqrs.Entities.IEntity"/> has been deleted, but not removed from the <see cref="T:Cqrs.DataStores.IDataStore`1"/>,
            this way entities can be retrieved so an un-deleted operation can be triggered.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.IEntity">
            <summary>
            A projection/entity.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.IEntity.Rsn">
            <summary>
            The identifier of the <see cref="T:Cqrs.Entities.IEntity"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.IEntity.SortingOrder">
            <summary>
            The order of this <see cref="T:Cqrs.Entities.IEntity"/> to sort by, by default.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.IEntity.IsDeleted">
            <summary>
            Indicates if this <see cref="T:Cqrs.Entities.IEntity"/> has been deleted, but not removed from the <see cref="T:Cqrs.DataStores.IDataStore`1"/>,
            this way entities can be retrieved so an un-deleted operation can be triggered.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.IntegerRange">
            <summary>
            A <see cref="T:Cqrs.Entities.Range`1"/> object for collecting a <see cref="T:System.Int32"/> lower and upper limit.
            </summary>
        </member>
        <member name="M:Cqrs.Entities.IntegerRange.#ctor">
            <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.IntegerRange"/> class.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.Range`1">
            <summary>
            A range object for collecting a lower and upper limit, such as a number or date range.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Range`1.From">
            <summary>
            The lower limit such as a from <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Range`1.To">
            <summary>
            The upper limit such as a to <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Range`1.IsFromInclusive">
            <summary>
            Is the value of <see cref="P:Cqrs.Entities.Range`1.From"/> inclusive or not. Defaults to true.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Range`1.IsToInclusive">
            <summary>
            Is the value of <see cref="P:Cqrs.Entities.Range`1.To"/> inclusive or not. Defaults to true.
            </summary>
        </member>
        <member name="T:Cqrs.Events.DefaultEventBuilder`1">
            <summary>
            Builds <see cref="T:Cqrs.Events.EventData"/> from various input formats serialising as JSON.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Events.DefaultEventBuilder`1.DefaultSettings">
            <summary>
            The default <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> to use.
            </summary>
        </member>
        <member name="M:Cqrs.Events.DefaultEventBuilder`1.SerialiseEventDataToString(Cqrs.Events.IEvent{`0})">
            <summary>
            Serialise the provided <paramref name="eventData"/> into JSON a <see cref="T:System.String"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to serialise.</param>
        </member>
        <member name="M:Cqrs.Events.DefaultEventBuilder`1.GetSerialisationSettings">
            <summary>
            Returns <see cref="P:Cqrs.Events.DefaultEventBuilder`1.DefaultSettings"/>
            </summary>
            <returns><see cref="P:Cqrs.Events.DefaultEventBuilder`1.DefaultSettings"/></returns>
        </member>
        <member name="T:Cqrs.Events.DefaultJsonSerializerSettings">
            <summary>
            Default settings for JSON serialisation  and deserialisation.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DefaultJsonSerializerSettings.DefaultSettings">
            <summary>
            System wide default <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Events.DefaultSnapshotBuilder">
            <summary>
            Builds <see cref="T:Cqrs.Events.EventData"/> from various input formats serialising as JSON.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DefaultSnapshotBuilder.DefaultSettings">
            <summary>
            The default <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> to use.
            </summary>
        </member>
        <member name="M:Cqrs.Events.DefaultSnapshotBuilder.SerialiseEventDataToString(Cqrs.Snapshots.Snapshot)">
            <summary>
            Serialise the provided <paramref name="snapshot"/> into JSON a <see cref="T:System.String"/>.
            </summary>
            <param name="snapshot">The <see cref="T:Cqrs.Snapshots.Snapshot"/> to serialise.</param>
        </member>
        <member name="M:Cqrs.Events.DefaultSnapshotBuilder.GetSerialisationSettings">
            <summary>
            Returns <see cref="P:Cqrs.Events.DefaultSnapshotBuilder.DefaultSettings"/>
            </summary>
            <returns><see cref="P:Cqrs.Events.DefaultSnapshotBuilder.DefaultSettings"/></returns>
        </member>
        <member name="T:Cqrs.Events.DtoAggregateEvent`2">
            <summary>
            A <see cref="T:Cqrs.Events.IEvent`1"/> for <see cref="T:Cqrs.Domain.IDto"/> objects
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TDto">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IDto"/> this command targets.</typeparam>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.Original">
            <summary>
            Gets or sets the original version of the <typeparamref name="TDto"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.New">
            <summary>
            Gets or sets the new version of the <typeparamref name="TDto"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Events.DtoAggregateEvent`2.#ctor(System.Guid,`1,`1)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.DtoAggregateEvent`2"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.Id">
            <summary>
            The identifier of the event itself.
            In some cases this may be the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> this command targets.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.Version">
            <summary>
            The new version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> that raised this.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.TimeStamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="M:Cqrs.Events.DtoAggregateEvent`2.GetEventType">
            <summary>
            Determines the <see cref="T:Cqrs.Events.DtoAggregateEventType"/> this <see cref="T:Cqrs.Events.IEvent`1"/> represents.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.AuthenticationToken">
            <summary>
            The <typeparamref name="TAuthenticationToken"/> of the entity that triggered the event to be raised.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Events.DtoAggregateEvent`2.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.OriginatingFramework">
            <summary>
            The originating framework this message was sent from.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.Frameworks">
            <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage"/> has been delivered to/sent via already.
            </summary>
        </member>
        <member name="T:Cqrs.Events.DtoAggregateEventType">
            <summary>
            The type of CRUD operation.
            </summary>
        </member>
        <member name="F:Cqrs.Events.DtoAggregateEventType.Unknown">
            <summary>
            An unknown CRUD operations.
            </summary>
        </member>
        <member name="F:Cqrs.Events.DtoAggregateEventType.Created">
            <summary>
            The Create CRUD operations.
            </summary>
        </member>
        <member name="F:Cqrs.Events.DtoAggregateEventType.Updated">
            <summary>
            The Update CRUD operations.
            </summary>
        </member>
        <member name="F:Cqrs.Events.DtoAggregateEventType.Deleted">
            <summary>
            The Delete CRUD operations.
            </summary>
        </member>
        <member name="T:Cqrs.Events.DuplicateCreateCommandEvent`1">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> that informs the system that an operation resulted in a duplicate.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.Id">
            <summary>
            The identifier of the command itself.
            In some cases this may be the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> this command targets.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.Version">
            <summary>
            The new version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> that raised this.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.TimeStamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.AuthenticationToken">
            <summary>
            The <typeparamref name="TAuthenticationToken"/> of the entity that triggered the event to be raised.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Events.DuplicateCreateCommandEvent`1.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.OriginatingFramework">
            <summary>
            The originating framework this message was sent from.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.Frameworks">
            <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage"/> has been delivered to/sent via already.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that already exists, but had another <see cref="F:Cqrs.Events.DtoAggregateEventType.Created"/> event raised.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.AggregateRsn">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that already exists, but had another <see cref="F:Cqrs.Events.DtoAggregateEventType.Created"/> event raised.
            </summary>
        </member>
        <member name="T:Cqrs.Events.EventBuilder`1">
            <summary>
            Builds <see cref="T:Cqrs.Events.EventData"/> from various input formats.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Events.EventBuilder`1.CreateFrameworkEvent(System.String,Cqrs.Events.IEvent{`0})">
            <summary>
            Create an <see cref="T:Cqrs.Events.EventData">framework event</see> with the provided <paramref name="eventData"/>.
            </summary>
            <param name="type">The name of the <see cref="T:System.Type"/> of the target object the serialised data is.</param>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to add to the <see cref="T:Cqrs.Events.EventData"/>.</param>
        </member>
        <member name="M:Cqrs.Events.EventBuilder`1.CreateFrameworkEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Create an <see cref="T:Cqrs.Events.EventData">framework event</see> with the provided <paramref name="eventData"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to add to the <see cref="T:Cqrs.Events.EventData"/>.</param>
        </member>
        <member name="M:Cqrs.Events.EventBuilder`1.SerialiseEventData(Cqrs.Events.IEvent{`0})">
            <summary>
            Serialise the provided <paramref name="eventData"/> into a <see cref="T:System.Byte"/> <see cref="T:System.Array"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to serialise.</param>
        </member>
        <member name="M:Cqrs.Events.EventBuilder`1.SerialiseEventDataToString(Cqrs.Events.IEvent{`0})">
            <summary>
            Serialise the provided <paramref name="eventData"/> into a <see cref="T:System.String"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to serialise.</param>
        </member>
        <member name="T:Cqrs.Events.EventData">
            <summary>
            Captures all the data relevant to an <see cref="T:Cqrs.Events.IEvent`1"/> for an <see cref="T:Cqrs.Events.IEventStore`1"/> to persist.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.Data">
            <summary>
            The data/content of the <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.EventId">
            <summary>
            The identifier of the <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.EventType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.AggregateId">
            <summary>
            The globally identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> , meaning it also includes <see cref="T:System.Type"/> information.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.AggregateRsn">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.Version">
            <summary>
            The new version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> that raised this.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.Timestamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Events.EventData.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventData.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.EventData"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Events.EventDataResolver`1">
            <summary>
            Resolves <see cref="T:Cqrs.Events.EventData"/>, <see cref="T:Cqrs.Services.ServiceRequestWithData`2" /> and <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/> parameter types when serialising with WCF.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventDataResolver`1.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Indicates if the provided <paramref name="dataContractType"/> is of type <see cref="T:Cqrs.Events.EventData"/>, <see cref="T:Cqrs.Services.ServiceRequestWithData`2" />, <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/>0
            OR if it is other resolvable.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventDataResolver`1.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Returns the <see cref="T:System.Type"/> if the <paramref name="typeName"/> is resolvable or if it is 
            of type <paramref name="typeName"/> is of type <see cref="T:Cqrs.Events.EventData"/>, <see cref="T:Cqrs.Services.ServiceRequestWithData`2" />, <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/>
            </summary>
        </member>
        <member name="T:Cqrs.Events.EventDeserialiser`1">
            <summary>
            Deserialises <see cref="T:Cqrs.Events.IEvent`1"/> from a serialised state.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Events.EventDeserialiser`1.DefaultSettings">
            <summary>
            The default <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> to use.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventDeserialiser`1.Deserialise(Cqrs.Events.EventData)">
            <summary>
            Deserialise the provided <paramref name="eventData"/> into an <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to Deserialise.</param>
        </member>
        <member name="M:Cqrs.Events.EventDeserialiser`1.GetSerialisationSettings">
            <summary>
            Returns <see cref="P:Cqrs.Events.EventDeserialiser`1.DefaultSettings"/>
            </summary>
            <returns><see cref="P:Cqrs.Events.EventDeserialiser`1.DefaultSettings"/></returns>
        </member>
        <member name="T:Cqrs.Events.EventExtensions">
            <summary>
            A set of extension method for <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventExtensions.GetIdentity``1(Cqrs.Events.IEvent{``0})">
            <summary>
            The identity of the target object of the provided <paramref name="event"/>.
            </summary>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to locate the identify from.</param>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
            <returns><see cref="P:Cqrs.Events.IEventWithIdentity`1.Rsn"/> or <see cref="P:Cqrs.Events.IEvent`1.Id"/>.</returns>
        </member>
        <member name="T:Cqrs.Events.EventStore`1">
            <summary>
            Stores instances of <see cref="T:Cqrs.Events.IEvent`1"/> for replay, <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> and <see cref="T:Cqrs.Domain.ISaga`1"/> rehydration.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="F:Cqrs.Events.EventStore`1.CqrsEventStoreStreamNamePattern">
            <summary>
            The pattern used to generate the stream name.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStore`1.EventBuilder">
            <summary>
            The <see cref="T:Cqrs.Events.IEventBuilder`1"/> used to build events.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStore`1.EventDeserialiser">
            <summary>
            The <see cref="T:Cqrs.Events.IEventDeserialiser`1"/> used to deserialise events.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStore`1.TelemetryHelper">
            <summary>
            The <see cref="T:Chinchilla.Logging.ITelemetryHelper"/> to use.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStore`1.Logger">
            <summary>
            The <see cref="T:Chinchilla.Logging.ILogger"/> to use.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.#ctor(Cqrs.Events.IEventBuilder{`0},Cqrs.Events.IEventDeserialiser{`0},Chinchilla.Logging.ILogger)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.EventStore`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Save``1(Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GenerateStreamName(System.Type,Cqrs.Events.IEvent{`0})">
            <summary>
            Generate a unique stream name based on the provided <paramref name="aggregateRootType"/> and the <see cref="P:Cqrs.Events.IEvent`1.Id"/> from the provided <paramref name="event"/>.
            </summary>
            <param name="aggregateRootType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to extract information from.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GenerateStreamName(System.Type,System.Guid)">
            <summary>
            Generate a unique stream name based on the provided <paramref name="aggregateRootType"/> and the <paramref name="aggregateId"/>.
            </summary>
            <param name="aggregateRootType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="aggregateId">The ID of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Save(System.Type,Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Get``1(System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <typeparamref name="T">aggregate root</typeparamref> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateRootType"/> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GetToVersion(System.Type,System.Guid,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateRootType"/> with the ID matching the provided <paramref name="aggregateId"/> up to and including the provided <paramref name="version"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="version">Load events up-to and including from this version</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GetToVersion``1(System.Guid,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <typeparamref name="T">aggregate root</typeparamref> with the ID matching the provided <paramref name="aggregateId"/> up to and including the provided <paramref name="version"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="version">Load events up-to and including from this version</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GetToDate(System.Type,System.Guid,System.DateTime)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateRootType"/> with the ID matching the provided <paramref name="aggregateId"/> up to and including the provided <paramref name="versionedDate"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GetToDate``1(System.Guid,System.DateTime)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <typeparamref name="T">aggregate root</typeparamref> with the ID matching the provided <paramref name="aggregateId"/> up to and including the provided <paramref name="versionedDate"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="versionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GetBetweenDates(System.Type,System.Guid,System.DateTime,System.DateTime)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateRootType"/> with the ID matching the provided <paramref name="aggregateId"/> from and including the provided <paramref name="fromVersionedDate"/> up to and including the provided <paramref name="toVersionedDate"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="fromVersionedDate">Load events from and including from this <see cref="T:System.DateTime"/></param>
            <param name="toVersionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GetBetweenDates``1(System.Guid,System.DateTime,System.DateTime)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <typeparamref name="T">aggregate root</typeparamref> with the ID matching the provided <paramref name="aggregateId"/> from and including the provided <paramref name="fromVersionedDate"/> up to and including the provided <paramref name="toVersionedDate"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="fromVersionedDate">Load events from and including from this <see cref="T:System.DateTime"/></param>
            <param name="toVersionedDate">Load events up-to and including from this <see cref="T:System.DateTime"/></param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Get(System.Guid)">
            <summary>
            Get all <see cref="T:Cqrs.Events.IEvent`1"/> instances for the given <paramref name="correlationId"/>.
            </summary>
            <param name="correlationId">The <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> instances to retrieve.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.PersistEvent(Cqrs.Events.EventData)">
            <summary>
            Persist the provided <paramref name="eventData"/> into storage.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to persist.</param>
        </member>
        <member name="T:Cqrs.Events.EventStoreRetentionLevelAttribute">
            <summary>
            Provides a mechanism to configure different <see cref="T:Cqrs.Events.IEventStore`1"/> instances to save the event to.
            This is useful if you have events that should be in hot storage with quick loads and events that should be in cold storage and are unlikely to be reloaded and use slower cheaper storage.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStoreRetentionLevelAttribute.RetentionLevel">
            <summary>
            The level of retention required. By specifying a value we look for a matching configured <see cref="T:Cqrs.Events.IEventStore`1"/> with the same level defined.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEvent`1">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> represents something that took place in the domain. They are always named with a past-participle verb, such as OrderConfirmed. It's not unusual, but not required, for an <see cref="T:Cqrs.Events.IEvent`1"/> to name an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Entities.IEntity"/> that it relates to; let the domain language be your guide.
            
            Since an <see cref="T:Cqrs.Events.IEvent`1"/> represents something in the past, it can be considered a statement of fact and used to take decisions in other parts of the system.
            </summary>
            <example>
            public class OrderConfirmed 
            {
            	public Guid OrderRsn;
            	public DateTime ConfirmationDate;
            }
            </example>
            <remarks>
            What does a <see cref="T:Cqrs.Commands.ICommand`1"/> or an <see cref="T:Cqrs.Events.IEvent`1"/> look like?
            
            An <see cref="T:Cqrs.Commands.ICommand`1"/> or <see cref="T:Cqrs.Events.IEvent`1"/> is simply a data structure that contain data for reading, and no behavior. We call such structures "Data Transfer Objects" (DTOs). The name indicates the purpose. In many languages they are represented as classes, but they are not true classes in the real OO sense.
            
            
            What is the difference between a <see cref="T:Cqrs.Commands.ICommand`1"/> and an <see cref="T:Cqrs.Events.IEvent`1"/>?
            
            Their intent.
            
            
            What is immutability? Why is a <see cref="T:Cqrs.Commands.ICommand`1"/> or <see cref="T:Cqrs.Events.IEvent`1"/> immutable?
            
            For the purpose of this question, immutability is not having any setters, or other methods which change internal state. The <see cref="T:System.String"/> type in is a familiar example; you never actually change an existing <see cref="T:System.String"/> value, you just create new <see cref="T:System.String"/> values based on old ones.
            
            An <see cref="T:Cqrs.Commands.ICommand`1"/> is immutable because their expected usage is to be sent directly to the domain model side for processing. They do not need to change during their projected lifetime in traveling from client to server.
            Sometimes however business logic dictates that a decision may be made to construct a <see cref="T:Cqrs.Commands.ICommand`1"/> and local variables should be used.
            
            An <see cref="T:Cqrs.Events.IEvent`1"/> is immutable because they represent domain actions that took place in the past. Unless you're Marty McFly, you can't change the past, and sometimes not even then.
            
            
            What is command upgrading?
            
            Upgrading an <see cref="T:Cqrs.Commands.ICommand`1"/> becomes necessary when new requirements cause an existing <see cref="T:Cqrs.Commands.ICommand`1"/> not to be sufficient. Maybe a new field needs to be added, for example, or maybe an existing field should really have been split into several different ones.
            
            
            How do I upgrade my <see cref="T:Cqrs.Commands.ICommand`1"/>s?
            
            How you do the upgrade depends how much control you have over your clients. If you can deploy your client updates and server updates together, just change things in both and deploy the updates. Job done. If not, it's usually best to have the updated <see cref="T:Cqrs.Commands.ICommand`1"/> be a new type and have the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> accept both for a while.
            
            
            Could you give an example of names of some versioned <see cref="T:Cqrs.Commands.ICommand`1"/>?
            
            Sure.
            
            UploadFile
            UploadFile_v2
            UploadFile_v3
            
            It's just a convention, but a sane one.
            ********************************************
            Also see http://cqrs.nu/Faq/commands-and-events.
            </remarks>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="P:Cqrs.Events.IEvent`1.Id">
            <summary>
            The ID of the <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.IEvent`1.Version">
            <summary>
            The version of the <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.IEvent`1.TimeStamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventBuilder`1">
            <summary>
            Builds <see cref="T:Cqrs.Events.EventData"/> from various input formats.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Events.IEventBuilder`1.CreateFrameworkEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Create an <see cref="T:Cqrs.Events.EventData">framework event</see> with the provided <paramref name="eventData"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to add to the <see cref="T:Cqrs.Events.EventData"/>.</param>
        </member>
        <member name="M:Cqrs.Events.IEventBuilder`1.CreateFrameworkEvent(System.String,Cqrs.Events.IEvent{`0})">
            <summary>
            Create an <see cref="T:Cqrs.Events.EventData">framework event</see> with the provided <paramref name="eventData"/>.
            </summary>
            <param name="type">The name of the <see cref="T:System.Type"/> of the target object the serialised data is.</param>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to add to the <see cref="T:Cqrs.Events.EventData"/>.</param>
        </member>
        <member name="T:Cqrs.Events.IEventDeserialiser`1">
            <summary>
            Deserialises <see cref="T:Cqrs.Events.IEvent`1"/> from a serialised state.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Events.IEventDeserialiser`1.Deserialise(Cqrs.Events.EventData)">
            <summary>
            Deserialise the provided <paramref name="eventData"/> into an <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to Deserialise.</param>
        </member>
        <member name="T:Cqrs.Events.IEventHandler`3">
            <summary>
            Responds to or "Handles" a <typeparamref name="TEvent"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
            <typeparam name="TTarget">The <see cref="T:System.Type"/> of the object that is targeted that needs concurrency.</typeparam>
            <typeparam name="TEvent">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Events.IEvent`1"/> that can be handled.</typeparam>
        </member>
        <member name="T:Cqrs.Events.IEventHandler`2">
            <summary>
            Responds to or "Handles" a <typeparamref name="TEvent"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
            <typeparam name="TEvent">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Events.IEvent`1"/> that can be handled.</typeparam>
        </member>
        <member name="T:Cqrs.Events.IEventHandler">
            <summary>
            Responds to or "Handles" a <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventPublisher`1">
            <summary>
            Publishes an <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Events.IEventPublisher`1.Publish``1(``0)">
            <summary>
            Publishes the provided <paramref name="event"/> on the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Events.IEventPublisher`1.Publish``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="events"/> on the event bus.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventReceiver">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Events.IEventReceiver.Start">
            <summary>
            Starts listening and processing instances of <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventReceiver`1">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Events.IEventReceiver`1.ReceiveEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Receives a <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventStore`1">
            <summary>
            Stores instances of <see cref="T:Cqrs.Events.IEvent`1"/> for replay, <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> and <see cref="T:Cqrs.Domain.ISaga`1"/> rehydration.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Events.IEventStore`1.Save``1(Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.IEventStore`1.Save(System.Type,Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.IEventStore`1.Get``1(System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <typeparamref name="T">aggregate root</typeparamref> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <pa